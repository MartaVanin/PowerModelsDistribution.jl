<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Engineering Model · PowerModelsDistribution</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PowerModelsDistribution logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerModelsDistribution</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li><a class="tocitem" href="../connections/">Connecting Components</a></li><li><a class="tocitem" href="../math-model/">Mathematical Model</a></li><li><a class="tocitem" href="../eng-data-model/">Engineering Data Model</a></li><li><a class="tocitem" href="../enums/">Enums in Engineering Model</a></li><li><a class="tocitem" href="../eng2math/">Conversion to Mathematical Model</a></li><li><a class="tocitem" href="../external-data-formats/">External Data Formats</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox" checked/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Engineering Model</a><ul class="internal"><li><a class="tocitem" href="#Imports"><span>Imports</span></a></li><li><a class="tocitem" href="#Parsing-Data"><span>Parsing Data</span></a></li><li><a class="tocitem" href="#Running-Optimal-Power-Flow"><span>Running Optimal Power Flow</span></a></li><li><a class="tocitem" href="#Engineering-Model-Transformations"><span>Engineering Model Transformations</span></a></li><li><a class="tocitem" href="#Mathematical-Model"><span>Mathematical Model</span></a></li><li><a class="tocitem" href="#Building-the-JuMP-Model"><span>Building the JuMP Model</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../engineering_model_helper_functions/">Engineering Model Helper Functions</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../formulations/">Network Formulations</a></li><li><a class="tocitem" href="../specifications/">Problem Specifications</a></li><li><a class="tocitem" href="../library/">Modeling Components</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../load-model/">Load Models</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../developer/">Developer</a></li><li><a class="tocitem" href="../formulation-details/">Formulation Details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Engineering Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Engineering Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/master/docs/src/engineering_model.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-the-PowerModelsDistribution-Data-Models"><a class="docs-heading-anchor" href="#Introduction-to-the-PowerModelsDistribution-Data-Models">Introduction to the PowerModelsDistribution Data Models</a><a id="Introduction-to-the-PowerModelsDistribution-Data-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-the-PowerModelsDistribution-Data-Models" title="Permalink"></a></h1><p>In this notebook we introduce the engineering data model added to PowerModelsDistribution in version v0.9.0. We will give several examples of how to use this new data model directly, including new transformations that have become easier with its introduction, how to convert it to the the lower-level mathematical model that was previously the only user interface we offered, and how to get various types of results using this new model.</p><h2 id="Imports"><a class="docs-heading-anchor" href="#Imports">Imports</a><a id="Imports-1"></a><a class="docs-heading-anchor-permalink" href="#Imports" title="Permalink"></a></h2><p>All commands in this document with no package namespace specified are directly exported by PowerModelsDistribution or already available in Julia base. Any commands that are only avaiable via an external package will be specified by including by using <code>import</code>, which will require specifying the originating package before the command, <em>e.g.</em> <code>Ipopt.Optimizer</code> as you will see below.</p><pre><code class="language-julia">using PowerModelsDistribution</code></pre><p>In these examples we will use the following optimization solvers, specified using <code>optimizer_with_attributes</code> from JuMP v0.21</p><pre><code class="language-julia">import Ipopt

ipopt_solver = optimizer_with_attributes(Ipopt.Optimizer, &quot;tol&quot;=&gt;1e-6, &quot;print_level&quot;=&gt;0)</code></pre><pre><code class="language-none">MathOptInterface.OptimizerWithAttributes(Ipopt.Optimizer, Pair{MathOptInterface.AbstractOptimizerAttribute, Any}[MathOpt
Interface.RawParameter(&quot;tol&quot;) =&gt; 1.0e-6, MathOptInterface.RawParameter(&quot;print_level&quot;) =&gt; 0])</code></pre><h2 id="Parsing-Data"><a class="docs-heading-anchor" href="#Parsing-Data">Parsing Data</a><a id="Parsing-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-Data" title="Permalink"></a></h2><p>Here we give the first example of how to parse data into the <code>ENGINEERING</code> data model structure, which is the default data structure type that the user will see without passing additional arguments, as we demonstrate later.</p><p>We start with a 3 bus unbalanced load case provided as a dss file in the <code>test</code> folder of the PowerModelsDistribution.jl repository</p><pre><code class="language-julia">eng = parse_file(&quot;../test/data/opendss/case3_unbalanced.dss&quot;)</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/case3_unbalanced.dss&quot;: No such file or directory</code></pre><p>Different information and warning messages will be given depending on the input file. In the case above, these messages all related to various parse notifications that arise during a parse of a dss file, and can be safely ignored</p><p>The resulting data structure is a Julia dictionary. The first notable field is <code>&quot;data_model&quot;</code> which specifies which data model this data structure corresponds to, in this case <code>ENGINEERING</code>. This value is expected to be an <code>Enum</code> of type <code>DataModel</code></p><p>The next notable field is <code>&quot;settings&quot;</code>, which contains some important default/starting values for the distribution network</p><pre><code class="language-julia">eng[&quot;settings&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><ul><li><code>&quot;sbase_default&quot;</code> is the starting value for the power base,</li><li><code>&quot;vbases_default&quot;</code> is the starting voltage base for the case, and multiple voltage bases can be specified, which would be useful in cases where there are multiple isolated islands with their own generation,</li><li><code>&quot;voltage_scale_factor&quot;</code> is a scaling factor for all voltage values, which in the case of OpenDSS is in kV by default</li><li><code>&quot;power_scale_factor&quot;</code> is a scaling factor for all power values</li><li><code>&quot;base_frequency&quot;</code> is the base frequency of the network in Hz, which is useful to know for mixed frequency networks</li></ul><p>Next we look at the <code>&quot;bus&quot;</code> components</p><pre><code class="language-julia">eng[&quot;bus&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>We can see there are three buses in this system, identified by ids <code>&quot;primary&quot;</code>, <code>&quot;sourcebus&quot;</code>, and <code>&quot;loadbus&quot;</code>. </p><p><strong>NOTE</strong>: In Julia, order of Dictionary keys is not fixed, nor does it retain the order in which it was parsed like <em>e.g.</em> <code>Vectors</code>. </p><p>Identifying components by non-integer names is a new feature of the <code>ENGINEERING</code> model, and makes network debugging more straightforward. </p><p><strong>NOTE</strong>: all names are converted to lowercase on parse from the originating dss file.</p><p>Each bus component has the following properties in the <code>ENGINEERING</code> model</p><pre><code class="language-julia">eng[&quot;bus&quot;][&quot;sourcebus&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><ul><li><code>&quot;terminals&quot;</code> indicates which terminals on the bus have active connections</li><li><code>&quot;grounded&quot;</code> indicates which terminals are grounded</li><li><code>&quot;rg&quot;</code> and <code>&quot;xg&quot;</code> indicate the grounding resistance and reactance of the ground</li><li><code>&quot;status&quot;</code> indicates whether a bus is <code>ENABLED</code> or <code>DISABLED</code>, and is specified for every component in the engineering model</li></ul><p>Next, we look at the <code>&quot;line&quot;</code> components, which is a generic name for both overhead lines and underground cables, which we do not differentiate between in the nomenclature</p><pre><code class="language-julia">eng[&quot;line&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><pre><code class="language-julia">eng[&quot;line&quot;][&quot;quad&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>Again, we see components identified by their OpenDSS names. A <code>&quot;line&quot;</code> is an edge object, which will always have the following properties:</p><ul><li><code>&quot;f_bus&quot;</code></li><li><code>&quot;t_bus&quot;</code></li><li><code>&quot;f_connections&quot;</code> - list of terminals to which the line is connected on the from-side</li><li><code>&quot;t_connections&quot;</code> - list of terminals to which the line is connected on the to-side</li></ul><p>Here we are also introduced to two important concepts, the <code>&quot;source_id&quot;</code>, which is an easy way to identify from where an object originates in the dss file, and a data type element, pointed to by <code>&quot;linecode&quot;</code> in this case.</p><p>A data type element is an element that does not represent a real engineering object, but only contains data that one of those real objects can refer to, in this case a linecode, which contains information like line resistance/reactance and conductance/susceptance.</p><pre><code class="language-julia">eng[&quot;linecode&quot;][&quot;4/0quad&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>Next, we introduce a node element, the <code>&quot;load&quot;</code> object, where we also see the first example of a specification of less than three phases at a time</p><pre><code class="language-julia">eng[&quot;load&quot;][&quot;l1&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>We can see that the length of the Vectors for <code>&quot;pd_nom&quot;</code> and <code>&quot;qd_nom&quot;</code> are only one, although the number of terminals listed in <code>&quot;connections&quot;</code> is two. This is because the connection is WYE, and therefore the final connection is a grounded neutral</p><p>Here we are also introduced to two new Enums, <code>WYE</code>, which gives the connection configuration, and <code>NO</code> under dispatchable, which indicates that if this case were used in an MLD problem, <em>i.e.</em> with <code>run_mc_mld</code> that this load would not be sheddable.</p><p>Finally, we show the generation source for this case, which in opendss is a voltage source named <code>&quot;source&quot;</code></p><pre><code class="language-julia">eng[&quot;voltage_source&quot;][&quot;source&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><ul><li><code>&quot;vm&quot;</code> - specifies the fixed voltage magnitudes per phase at the bus</li><li><code>&quot;va&quot;</code> - specifies the fixed reference angles per phases at the bus</li><li><code>&quot;rs&quot;</code> and <code>&quot;xs&quot;</code> specifies internal impedances of the voltage source</li></ul><h3 id="Importing-raw-dss-properties"><a class="docs-heading-anchor" href="#Importing-raw-dss-properties">Importing raw dss properties</a><a id="Importing-raw-dss-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-raw-dss-properties" title="Permalink"></a></h3><p>In case there are additional properties that you want to use from dss, it is possible to import those directly into the <code>ENGINEERING</code> (and <code>MATHEMATICAL</code>) data structure with the <code>import_all</code> keyword argument</p><pre><code class="language-julia">eng_all = parse_file(&quot;../test/data/opendss/case3_unbalanced.dss&quot;; import_all=true)

eng_all[&quot;line&quot;]</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/case3_unbalanced.dss&quot;: No such file or directory</code></pre><p>You will note the presence of <code>&quot;dss&quot;</code> dictionaries under components, and <code>&quot;dss_options&quot;</code> at the root level</p><h3 id="Time-Series-Parsing-Example"><a class="docs-heading-anchor" href="#Time-Series-Parsing-Example">Time Series Parsing Example</a><a id="Time-Series-Parsing-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Series-Parsing-Example" title="Permalink"></a></h3><p>In the <code>ENGINEERING</code> model, we have included the <code>time_series</code> data type, which holds all time series data and can be referred to similar to <code>&quot;linecode&quot;</code> as demonstrated above.</p><p>Below we can see an example of a parse that includes some time_series components</p><pre><code class="language-julia">eng_ts = parse_file(&quot;../test/data/opendss/case3_balanced.dss&quot;; time_series=&quot;daily&quot;)</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/case3_balanced.dss&quot;: No such file or directory</code></pre><pre><code class="language-julia">eng_ts[&quot;load&quot;][&quot;l1&quot;][&quot;time_series&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ts not defined</code></pre><p>You can see that under the actual component, in this case a <code>&quot;load&quot;</code>, that there is a <code>&quot;time_series&quot;</code> dictionary that contains <code>ENGINEERING</code> model variable names and references to the identifiers of a root-level <code>time_series</code> object, </p><pre><code class="language-julia">eng_ts[&quot;time_series&quot;][&quot;ls1&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ts not defined</code></pre><p>This feature is useful for building multinetwork data structures, which will be described below in the section on the <code>MATHEMATICAL</code> model</p><h2 id="Running-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Running-Optimal-Power-Flow">Running Optimal Power Flow</a><a id="Running-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Optimal-Power-Flow" title="Permalink"></a></h2><p>In this section we introduce how to run an optimal power flow (opf) in PowerModelsDistribution on an engineering data model</p><p>In order to run an OPF problem you will need</p><ol><li>a data model</li><li>a formulation</li><li>a solver</li></ol><p>In these examples we will use the <code>eng</code> model we worked with above, the <code>ACPPowerModel</code>, which is a AC power flow formulation in polar coordinates, and the <code>ipopt_solver</code> we already defined above</p><pre><code class="language-julia">result = solve_mc_opf(eng, ACPPowerModel, ipopt_solver)</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>The result of <code>solve_mc_opf</code> will be very familiar to those who are already familiar with PowerModels and PowerModelsDistribution. The notable difference will be in the <code>&quot;solution&quot;</code> dictionary</p><pre><code class="language-julia">result[&quot;solution&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: result not defined</code></pre><p>Here you can see that the solution comes back out by default into the same data model as is provided by the user to the <code>run_</code> command, as well as being in SI units, as opposed to per unit, which is used during the solve. For example,</p><pre><code class="language-julia">result[&quot;solution&quot;][&quot;bus&quot;][&quot;loadbus&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: result not defined</code></pre><p>If for some reason you want to return the result in per-unit rather than SI, you can specify this in the <code>run_</code> command by</p><pre><code class="language-julia">result_pu = solve_mc_opf(eng, ACPPowerModel, ipopt_solver; make_si=false)

result_pu[&quot;solution&quot;][&quot;bus&quot;][&quot;loadbus&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><h3 id="Branch-Flow-formulations"><a class="docs-heading-anchor" href="#Branch-Flow-formulations">Branch Flow formulations</a><a id="Branch-Flow-formulations-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Flow-formulations" title="Permalink"></a></h3><p>Previously, to use a branch flow formulation, such as <code>SOCNLPUBFPowerModel</code>, it was required to use a different <code>run_</code> command, but now, by using multiple dispatch we have simplified this for the user</p><pre><code class="language-julia">result_bf = solve_mc_opf(eng, SOCNLPUBFPowerModel, ipopt_solver)</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><h3 id="Running-Time-Series-Models"><a class="docs-heading-anchor" href="#Running-Time-Series-Models">Running Time Series Models</a><a id="Running-Time-Series-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Time-Series-Models" title="Permalink"></a></h3><p>By default, <code>time_series</code> object will be ignored when running a model. To use the time series information you will need to have a multinetwork problem specification</p><p>In the example below we use a test case, which is not exported by default, and therefore requires the specification of the PowerModelsDistribution namespace</p><pre><code class="language-julia">result_mn = PowerModelsDistribution._solve_mn_mc_opb(eng_ts, NFAPowerModel, ipopt_solver)</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ts not defined</code></pre><h2 id="Engineering-Model-Transformations"><a class="docs-heading-anchor" href="#Engineering-Model-Transformations">Engineering Model Transformations</a><a id="Engineering-Model-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Engineering-Model-Transformations" title="Permalink"></a></h2><p>One of the power things about the engineering model is that data transformations are much more simple. Here we illustrate two examples that are currently included in PowerModelsDistribution, but writing your own data transformation functions will be trivial, as we will show.</p><p><strong>Note</strong>: In v0.9, <code>apply_kron_reduction!</code> and <code>apply_phase_projection!</code> are applied by default, but can be disabled with the keyword arguments <code>kron_reduced=false</code> and <code>project_phases=false</code>, respectively in <code>parse_file</code> or <code>transform_data_model</code>.</p><p>First, there are several objects that have loss models by default when parsing from dss files, such as voltage sources, transformers, and switches. To remove these loss models, therefore making these components lossless, we can use the included <code>make_lossess!</code> function. Here we use a basic 2-winding wye-wye connected transformer case from <code>test</code> to illustrate this</p><pre><code class="language-julia">eng_ut = parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;)

eng_ut[&quot;transformer&quot;][&quot;tx1&quot;]</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;: No such file or directory</code></pre><p>We can see that <code>&quot;noloadloss&quot;</code>, <code>&quot;rw&quot;</code>, and <code>&quot;imag&quot;</code> are non-zero, but if we apply the <code>make_lossless!</code> function we can see these parameters are set to zero, effectively eliminating the losses</p><pre><code class="language-julia">make_lossless!(eng_ut)

eng_ut[&quot;transformer&quot;][&quot;tx1&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ut not defined</code></pre><p>Alternatively, we can apply this function at parse</p><pre><code class="language-julia">eng_ut = parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;; transformations=[make_lossless!])

eng_ut[&quot;transformer&quot;][&quot;tx1&quot;]</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;: No such file or directory</code></pre><p>Another transformation function included in PowerModelsDistribution is the <code>apply_voltage_bounds!</code> function, which will apply some voltage bounds in SI units, given some percent value, <em>e.g.</em> if we want the lower bound on voltage to be <code>0.9</code> and upper bound <code>1.1</code> after per-unit conversion</p><pre><code class="language-julia">apply_voltage_bounds!(eng_ut; vm_lb=0.9, vm_ub=1.1)

eng_ut[&quot;bus&quot;][&quot;2&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ut not defined</code></pre><p>Alternatively, this can be specified at parse by</p><pre><code class="language-julia">eng_ut = parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;; transformations=[make_lossless!, (apply_voltage_bounds!, &quot;vm_lb&quot;=&gt;0.9, &quot;vm_ub&quot;=&gt;1.1)])

eng_ut[&quot;bus&quot;][&quot;2&quot;]</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;: No such file or directory</code></pre><h3 id="Transformations-on-Multinetworks"><a class="docs-heading-anchor" href="#Transformations-on-Multinetworks">Transformations on Multinetworks</a><a id="Transformations-on-Multinetworks-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations-on-Multinetworks" title="Permalink"></a></h3><p>Transformations on Multinetworks should happen <strong>before</strong> the network is converted into a <code>MATHEMATICAL</code> data model, so that they can generally follow the same pattern as shown above and can be seen in the <code>make_lossless!</code> and <code>apply_voltage_bounds!</code> functions already in PowerModelsDistribution</p><h2 id="Mathematical-Model"><a class="docs-heading-anchor" href="#Mathematical-Model">Mathematical Model</a><a id="Mathematical-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Model" title="Permalink"></a></h2><p>In this section we introduce the mathematical model, which was the previous user-facing model in PowerModelsDistribution, explain how conversions between the model happen in practice, and give an example of how to do this conversion manually</p><p>In practice, unless the user is interested, the conversion between the <code>ENGINEERING</code> and <code>MATHEMATICAL</code> models should be seemless and invisible to the user. By providing an <code>ENGINEERING</code> model to a <code>run_</code> command the <code>run_mc_model</code> command will know to convert the model to <code>MATHEMATICAL</code>, which will be used to the generate the JuMP model that will actually be optimized. Similarly, the solution generated by this optimization will be automatically converted back to the format of the <code>ENGINEERING</code> model.</p><p>Let&#39;s first take a look at how to convert to the <code>MATHEMATICAL</code> model</p><pre><code class="language-julia">math = transform_data_model(eng)</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>There are a couple of things to notice right away. First, the data model transform automatically converts the model to per-unit. Second, there are a lot of empty component sets, whereas in the <code>ENGINEERING</code> model, only component types that had components in them were listed. In the <code>MATHEMATICAL</code> model certain component dictionaries are always expected to exist, and the <code>eng2math</code> conversion functions will automatically populate these.</p><p>Next, there are a few unusal fields, such as <code>&quot;settings&quot;</code>, which previously didn&#39;t exist in the <code>MATHEMATICAL</code> model. This is used for the per-unit conversion specifically in PowerModelsDistribution. Also, is the <code>&quot;map&quot;</code> field, which is a <code>Vector</code> of Dictionaries that enable the conversion back to <code>ENGINEERING</code> from <code>MATHEMATICAL</code>. Without this it would be impossible to convert back, and in fact only the solution can be converted, because some properties are combined destructively during the conversion to the <code>MATHEMATICAL</code> model, and therefore cannot be reverse engineered. However, since the conversion to <code>MATHEMATICAL</code> is not in-place, you will always have a copy of <code>eng</code> alongside <code>math</code>.</p><p>Here is an example of one of the <code>&quot;map&quot;</code> entries</p><pre><code class="language-julia">math[&quot;map&quot;][end]</code></pre><pre><code class="language-none">Error: UndefVarError: math not defined</code></pre><p>Alternatively, the <code>MATHEMATICAL</code> model can be returned directly from the <code>parse_file</code> command with the <code>data_model</code> keyword argument</p><pre><code class="language-julia">math = parse_file(&quot;../test/data/opendss/case3_unbalanced.dss&quot;; data_model=MATHEMATICAL)</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/case3_unbalanced.dss&quot;: No such file or directory</code></pre><h3 id="Multinetworks"><a class="docs-heading-anchor" href="#Multinetworks">Multinetworks</a><a id="Multinetworks-1"></a><a class="docs-heading-anchor-permalink" href="#Multinetworks" title="Permalink"></a></h3><p>In this subsection we cover parsing into a multinetwork data structure, which is a structure that only exists in the <code>MATHEMATICAL</code> model</p><p>For those unfamiliar, the InfrastructureModels family of packages has a feature called multinetworks, which is useful for, among other things, running optimization problems on time series type problems. </p><p>Multinetwork data structures are formatted like so</p><p>mn = Dict{String,Any}(     &quot;multinetwork&quot; =&gt; true,     &quot;nw&quot; =&gt; Dict{String,Any}(         &quot;1&quot; =&gt; Dict{String,Any}(             &quot;bus&quot; =&gt; Dict{String,Any}(),             ...         ),         ...     ),     ... )</p><p>To automatically create a multinetwork structure from an engineering model that contains <code>time_series</code> elements, we can use the <code>build_multinetwork</code> keyword argument in <code>transform_data_model</code></p><pre><code class="language-julia">math_mn = transform_data_model(eng_ts; build_multinetwork=true)</code></pre><pre><code class="language-none">Error: UndefVarError: eng_ts not defined</code></pre><p>Alternatively, we can use <code>parse_file</code> with the <code>build_multinetwork</code> keyword argument combined with <code>data_model=MATHEMATICAL</code></p><pre><code class="language-julia">math_mn = parse_file(&quot;../test/data/opendss/case3_balanced.dss&quot;; build_multinetwork=true, data_model=MATHEMATICAL)</code></pre><pre><code class="language-none">Error: SystemError: opening file &quot;../test/data/opendss/case3_balanced.dss&quot;: No such file or directory</code></pre><h3 id="Running-MATHEMATICAL-models"><a class="docs-heading-anchor" href="#Running-MATHEMATICAL-models">Running <code>MATHEMATICAL</code> models</a><a id="Running-MATHEMATICAL-models-1"></a><a class="docs-heading-anchor-permalink" href="#Running-MATHEMATICAL-models" title="Permalink"></a></h3><p>There is very little difference from the user point-of-view in running <code>MATHEMATICAL</code> models other than the results will not be automatically converted back to the the format of the <code>ENGINEERING</code> model</p><pre><code class="language-julia">result_math = solve_mc_opf(math, ACPPowerModel, ipopt_solver)

result_math[&quot;solution&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: math not defined</code></pre><p>It is also possible to manually convert the solution back to the <code>ENGINEERING</code> format, provided you have the <strong>map</strong></p><pre><code class="language-julia">sol_eng = transform_solution(result_math[&quot;solution&quot;], math)</code></pre><pre><code class="language-none">Error: UndefVarError: result_math not defined</code></pre><h4 id="Running-MATHEMATICAL-Multinetworks"><a class="docs-heading-anchor" href="#Running-MATHEMATICAL-Multinetworks">Running <code>MATHEMATICAL</code> Multinetworks</a><a id="Running-MATHEMATICAL-Multinetworks-1"></a><a class="docs-heading-anchor-permalink" href="#Running-MATHEMATICAL-Multinetworks" title="Permalink"></a></h4><p>As with the <code>ENGINEERING</code> example of running a multinetwork problem, you will need a multinetwork problem specification, and as with the previous single <code>MATHEMATICAL</code> network example above, we only obtain the <code>MATHEMATICAL</code> solution, and can transform the solution in the same manner as before</p><pre><code class="language-julia">result_math_mn = PowerModelsDistribution._solve_mn_mc_opb(math_mn, NFAPowerModel, ipopt_solver)

result_math_mn[&quot;solution&quot;][&quot;nw&quot;][&quot;1&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: math_mn not defined</code></pre><pre><code class="language-julia">sol_eng_mn = transform_solution(result_math_mn[&quot;solution&quot;], math_mn)

sol_eng_mn[&quot;nw&quot;][&quot;1&quot;]</code></pre><pre><code class="language-none">Error: UndefVarError: result_math_mn not defined</code></pre><h2 id="Building-the-JuMP-Model"><a class="docs-heading-anchor" href="#Building-the-JuMP-Model">Building the JuMP Model</a><a id="Building-the-JuMP-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-JuMP-Model" title="Permalink"></a></h2><p>In some cases the user will want to directly build the JuMP model, which would traditionally be done with <code>instantiate_model</code> from PowerModels. In order to facilitate using the <code>ENGINEERING</code> model we have introduced <code>instantiate_mc_model</code> to aid in the generation of the JuMP model. <code>instantiate_mc_model</code> will automatically convert the data model to MATHEMATICAL if necessary (notifying the user of the conversion), and pass the MATHEMATICAL model off to PowerModels&#39; <code>instantiate_model</code> with <code>ref_add_arcs_transformer!</code> in <code>ref_extensions</code>, which is a required ref extension for PowerModelsDistribution.</p><pre><code class="language-julia">pm_eng = instantiate_mc_model(eng, NFAPowerModel, build_mc_opf)

print(pm_eng.model)</code></pre><pre><code class="language-none">Error: UndefVarError: eng not defined</code></pre><p>This is equivalent to</p><pre><code class="language-julia">import PowerModels

pm_math = PowerModels.instantiate_model(math, NFAPowerModel, build_mc_opf; ref_extensions=[ref_add_arcs_transformer!])

print(pm_math.model)</code></pre><pre><code class="language-none">Error: UndefVarError: math not defined</code></pre><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>This concludes the introduction to the <code>ENGINEERING</code> data model and conversion to the <code>MATHEMATICAL</code> model. We hope that you will find this new data model abstraction easy to use and simple to understand</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../external-data-formats/">« External Data Formats</a><a class="docs-footer-nextpage" href="../engineering_model_helper_functions/">Engineering Model Helper Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 7 April 2021 22:01">Wednesday 7 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
