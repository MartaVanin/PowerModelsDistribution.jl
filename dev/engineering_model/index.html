<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Engineering Model · PowerModelsDistribution</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PowerModelsDistribution logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerModelsDistribution</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li><a class="tocitem" href="../connections/">Connecting Components</a></li><li><a class="tocitem" href="../math-model/">Mathematical Model</a></li><li><a class="tocitem" href="../eng-data-model/">Engineering Data Model</a></li><li><a class="tocitem" href="../enums/">Enums in Engineering Model</a></li><li><a class="tocitem" href="../eng2math/">Conversion to Mathematical Model</a></li><li><a class="tocitem" href="../external-data-formats/">External Data Formats</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox" checked/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../beginners_guide/">Beginners Guide</a></li><li class="is-active"><a class="tocitem" href>Engineering Model</a></li><li><a class="tocitem" href="../engineering_model_helper_functions/">Engineering Model Helper Functions</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../formulations/">Network Formulations</a></li><li><a class="tocitem" href="../specifications/">Problem Specifications</a></li><li><a class="tocitem" href="../library/">Modeling Components</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../load-model/">Load Models</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../developer/">Developer</a></li><li><a class="tocitem" href="../formulation-details/">Formulation Details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Engineering Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Engineering Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsDistribution.jl/blob/master/examples/engineering_model.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia">### A Pluto.jl notebook ###</code></pre><p>v0.14.2</p><pre><code class="language-julia">using Markdown
using InteractiveUtils</code></pre><p>╔═╡ 2661286b-2d18-42e3-b309-7974fc2db425</p><pre><code class="language-julia">begin
	import Pkg
	Pkg.activate(mktempdir())
	Pkg.Registry.update()
	Pkg.add([
			Pkg.PackageSpec(;name=&quot;Revise&quot;),
			Pkg.PackageSpec(;name=&quot;CodeTracking&quot;),
			Pkg.PackageSpec(;name=&quot;PlutoUI&quot;),
			Pkg.PackageSpec(;name=&quot;PowerModelsDistribution&quot;, version=&quot;0.11&quot;),
			Pkg.PackageSpec(;name=&quot;PowerModelsAnalytics&quot;, version=&quot;0.4.1&quot;),
			Pkg.PackageSpec(;name=&quot;InfrastructureModels&quot;, version=&quot;0.6&quot;),
			Pkg.PackageSpec(;name=&quot;JuMP&quot;, version=&quot;0.21.7&quot;),
			Pkg.PackageSpec(;name=&quot;Ipopt&quot;, version=&quot;0.6.5&quot;),
			Pkg.PackageSpec(;name=&quot;JSON&quot;, version=&quot;0.21&quot;),
			])
end</code></pre><pre class="documenter-example-output">  Activating new environment at `/tmp/jl_MZrvDi/Project.toml`
    Updating registry at `~/.julia/registries/General`
   Resolving package versions...
    Updating `/tmp/jl_MZrvDi/Project.toml`
  [da1fd8a2] + CodeTracking v1.0.5
  [2030c09a] + InfrastructureModels v0.6.0
  [b6b21f68] + Ipopt v0.6.5
  [682c06a0] + JSON v0.21.1
  [4076af6c] + JuMP v0.21.7
  [7f904dfe] + PlutoUI v0.7.6
  [7425d11c] + PowerModelsAnalytics v0.4.1
  [d7431456] + PowerModelsDistribution v0.11.0
  [295af30f] + Revise v3.1.15
    Updating `/tmp/jl_MZrvDi/Manifest.toml`
  [ec485272] + ArnoldiMethod v0.1.0
  [6e4b80f9] + BenchmarkTools v0.5.0
  [b99e7846] + BinaryProvider v0.5.10
  [49dc2e85] + Calculus v0.5.1
  [d360d2e6] + ChainRulesCore v0.9.37
  [da1fd8a2] + CodeTracking v1.0.5
  [523fee87] + CodecBzip2 v0.7.2
  [944b1d66] + CodecZlib v0.7.0
  [3da002f7] + ColorTypes v0.10.12
  [c3611d14] + ColorVectorSpace v0.9.2
  [5ae59095] + Colors v0.12.7
  [bbf7d656] + CommonSubexpressions v0.3.0
  [34da2185] + Compat v3.27.0
  [8f4d0f93] + Conda v1.5.1
  [187b0558] + ConstructionBase v1.1.0
  [9a962f9c] + DataAPI v1.6.0
  [864edb3b] + DataStructures v0.18.9
  [e2d170a0] + DataValueInterfaces v1.0.0
  [e7dc6d0d] + DataValues v0.4.13
  [163ba53b] + DiffResults v1.0.3
  [b552c78f] + DiffRules v1.0.2
  [e2ba6199] + ExprTools v0.1.3
  [8f5d6c58] + EzXML v1.1.0
  [5789e2e9] + FileIO v1.6.5
  [8fc22ac5] + FilePaths v0.8.2
  [48062228] + FilePathsBase v0.9.10
  [53c48c17] + FixedPointNumbers v0.8.4
  [f6369f11] + ForwardDiff v0.10.18
  [c27321d9] + Glob v1.3.0
  [cd3eb016] + HTTP v0.9.5
  [d25df0c9] + Inflate v0.1.2
  [2030c09a] + InfrastructureModels v0.6.0
  [83e8ac13] + IniFile v0.5.0
  [b6b21f68] + Ipopt v0.6.5
  [82899510] + IteratorInterfaceExtensions v1.0.0
  [692b3bcd] + JLLWrappers v1.2.0
  [682c06a0] + JSON v0.21.1
  [7d188eb4] + JSONSchema v0.3.3
  [4076af6c] + JuMP v0.21.7
  [aa1ae85d] + JuliaInterpreter v0.8.13
  [093fc24a] + LightGraphs v1.3.5
  [e6f89c97] + LoggingExtras v0.4.6
  [6f1432cf] + LoweredCodeUtils v2.0.0
  [1914dd2f] + MacroTools v0.5.6
  [b8f27783] + MathOptInterface v0.9.20
  [fdba3010] + MathProgBase v0.7.8
  [739be429] + MbedTLS v1.0.3
  [f28f55f0] + Memento v1.1.2
  [e1d29d7a] + Missings v0.4.5
  [78c3b35d] + Mocking v0.7.1
  [d8a4904e] + MutableArithmetics v0.2.17
  [77ba4419] + NaNMath v0.3.5
  [2bd173c7] + NodeJS v1.1.2
  [bac558e1] + OrderedCollections v1.4.0
  [69de0a69] + Parsers v1.1.0
  [7f904dfe] + PlutoUI v0.7.6
  [7425d11c] + PowerModelsAnalytics v0.4.1
  [d7431456] + PowerModelsDistribution v0.11.0
  [438e738f] + PyCall v1.92.3
  [3cdcf5f2] + RecipesBase v1.1.1
  [189a3867] + Reexport v1.0.0
  [ae029012] + Requires v1.1.3
  [295af30f] + Revise v3.1.15
  [efcf1570] + Setfield v0.7.0
  [699a6c99] + SimpleTraits v0.9.3
  [276daf66] + SpecialFunctions v1.3.0
  [90137ffa] + StaticArrays v1.1.0
  [fd094767] + Suppressor v0.2.0
  [cea106d9] + Syslogs v0.3.0
  [3783bdb8] + TableTraits v1.0.1
  [382cd787] + TableTraitsUtils v1.0.1
  [62fd8b95] + TensorCore v0.1.1
  [f269a46b] + TimeZones v1.5.3
  [3bb67fe8] + TranscodingStreams v0.9.5
  [30578b45] + URIParser v0.4.1
  [5c2747f8] + URIs v1.2.0
  [239c3e63] + Vega v2.1.1
  [81def892] + VersionParsing v1.2.0
  [a5390f91] + ZipFile v0.9.3
  [ae81ac8f] + ASL_jll v0.1.2+0
  [6e34b625] + Bzip2_jll v1.0.6+5
  [9cc047cb] + Ipopt_jll v3.13.4+2
  [94ce4f54] + Libiconv_jll v1.16.0+7
  [d00139f3] + METIS_jll v5.1.0+5
  [d7ed1dd3] + MUMPS_seq_jll v5.2.1+4
  [656ef2d0] + OpenBLAS32_jll v0.3.12+1
  [efe28fd5] + OpenSpecFun_jll v0.5.3+4
  [02c8fc9c] + XML2_jll v2.9.11+0
  [0dad84c5] + ArgTools
  [56f22d72] + Artifacts
  [2a0f44e3] + Base64
  [ade2ca70] + Dates
  [8bb1440f] + DelimitedFiles
  [8ba89e20] + Distributed
  [f43a241f] + Downloads
  [7b1f6079] + FileWatching
  [9fa8497b] + Future
  [b77e0a4c] + InteractiveUtils
  [b27032c2] + LibCURL
  [76f85450] + LibGit2
  [8f399da3] + Libdl
  [37e2e46d] + LinearAlgebra
  [56ddb016] + Logging
  [d6f4376e] + Markdown
  [a63ad114] + Mmap
  [ca575930] + NetworkOptions
  [44cfe95a] + Pkg
  [de0858da] + Printf
  [3fa0cd96] + REPL
  [9a3f8284] + Random
  [ea8e919c] + SHA
  [9e88b42a] + Serialization
  [1a1011a3] + SharedArrays
  [6462fe0b] + Sockets
  [2f01184e] + SparseArrays
  [10745b16] + Statistics
  [fa267f1f] + TOML
  [a4e569a6] + Tar
  [8dfed614] + Test
  [cf7118a7] + UUIDs
  [4ec0a83e] + Unicode
  [e66e0078] + CompilerSupportLibraries_jll
  [deac9b47] + LibCURL_jll
  [29816b5a] + LibSSH2_jll
  [c8ffd9c3] + MbedTLS_jll
  [14a3606d] + MozillaCACerts_jll
  [83775a58] + Zlib_jll
  [8e850ede] + nghttp2_jll
  [3f19e933] + p7zip_jll</pre><p>╔═╡ f30cd0d0-b0da-4f63-a245-568a763a93d8</p><pre><code class="language-julia">begin
	using PowerModelsDistribution
	using Ipopt
end</code></pre><p>╔═╡ c55b2c42-9d27-11eb-24ca-e90a5472ffbb</p><pre><code class="language-">md&quot;&quot;&quot;</code></pre><p>Introduction to the PowerModelsDistribution Data Models</p><pre><code class="language-julia">In this notebook we introduce the engineering data model added to PowerModelsDistribution in version v0.9.0. We will give several examples of how to use this new data model directly, including new transformations that have become easier with its introduction, how to convert it to the the lower-level mathematical model that was previously the only user interface we offered, and how to get various types of results using this new model.

# Julia Environment Setup

The following code block will setup a Julia environment for you with the correct versions of packages for this Pluto notebook.
&quot;&quot;&quot;</code></pre><p>╔═╡ de92bc20-b125-4f3d-930a-b1da63d5cef5</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Imports

All commands in this document with no package namespace specified are directly exported by PowerModelsDistribution or already available in Julia base. Any commands that are only avaiable via an external package will be specified by including by using `import`, which will require specifying the originating package before the command, _e.g._ `Ipopt.Optimizer` as you will see below.
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Imports</h1>
<p>All commands in this document with no package namespace specified are directly exported by PowerModelsDistribution or already available in Julia base. Any commands that are only avaiable via an external package will be specified by including by using <code>import</code>, which will require specifying the originating package before the command, <em>e.g.</em> <code>Ipopt.Optimizer</code> as you will see below.</p>
</div><p>╔═╡ ac94e556-b544-4ca6-87bd-ff2d7a7414e7</p><pre><code class="language-julia">pmd_path = joinpath(dirname(pathof(PowerModelsDistribution)), &quot;..&quot;)</code></pre><pre class="documenter-example-output">&quot;/home/runner/work/PowerModelsDistribution.jl/PowerModelsDistribution.jl/src/..&quot;</pre><p>╔═╡ 1e791262-261d-4756-bec4-edebe4732700</p><pre><code class="language-julia">md&quot;In these examples we will use the following optimization solvers, specified using `optimizer_with_attributes` from JuMP v0.21&quot;</code></pre><div class="markdown"><p>In these examples we will use the following optimization solvers, specified using <code>optimizer_with_attributes</code> from JuMP v0.21</p>
</div><p>╔═╡ 89de80df-1dd0-4f94-a27d-74693a978059</p><pre><code class="language-julia">ipopt_solver = optimizer_with_attributes(Ipopt.Optimizer, &quot;tol&quot;=&gt;1e-6, &quot;print_level&quot;=&gt;0)</code></pre><pre class="documenter-example-output">MathOptInterface.OptimizerWithAttributes(Ipopt.Optimizer, Pair{MathOptInterface.AbstractOptimizerAttribute, Any}[MathOptInterface.RawParameter(&quot;tol&quot;) =&gt; 1.0e-6, MathOptInterface.RawParameter(&quot;print_level&quot;) =&gt; 0])</pre><p>╔═╡ e22a7d3e-3f21-41b0-abf2-2c723e87c57e</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Parsing Data

Here we give the first example of how to parse data into the `ENGINEERING` data model structure, which is the default data structure type that the user will see without passing additional arguments, as we demonstrate later.

We start with a 3 bus unbalanced load case provided as a dss file in the `test` folder of the PowerModelsDistribution.jl repository
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Parsing Data</h1>
<p>Here we give the first example of how to parse data into the <code>ENGINEERING</code> data model structure, which is the default data structure type that the user will see without passing additional arguments, as we demonstrate later.</p>
<p>We start with a 3 bus unbalanced load case provided as a dss file in the <code>test</code> folder of the PowerModelsDistribution.jl repository</p>
</div><p>╔═╡ 5fe2d186-40c6-46c2-823e-9401cb3b6d6c</p><pre><code class="language-julia">eng = parse_file(&quot;$pmd_path/test/data/opendss/case3_unbalanced.dss&quot;)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 10 entries:
  &quot;voltage_source&quot; =&gt; Dict{String, Any}(&quot;source&quot;=&gt;Dict{String, Any}(&quot;source_id&quot;…
  &quot;name&quot;           =&gt; &quot;3bus_example&quot;
  &quot;line&quot;           =&gt; Dict{String, Any}(&quot;quad&quot;=&gt;Dict{String, Any}(&quot;cm_ub&quot;=&gt;[400…
  &quot;conductor_ids&quot;  =&gt; [1, 2, 3, 4]
  &quot;settings&quot;       =&gt; Dict{String, Any}(&quot;sbase_default&quot;=&gt;500.0, &quot;vbases_default…
  &quot;files&quot;          =&gt; [&quot;/home/runner/work/PowerModelsDistribution.jl/PowerModel…
  &quot;load&quot;           =&gt; Dict{String, Any}(&quot;l2&quot;=&gt;Dict{String, Any}(&quot;source_id&quot;=&gt;&quot;l…
  &quot;bus&quot;            =&gt; Dict{String, Any}(&quot;primary&quot;=&gt;Dict{String, Any}(&quot;rg&quot;=&gt;Floa…
  &quot;linecode&quot;       =&gt; Dict{String, Any}(&quot;556mcm&quot;=&gt;Dict{String, Any}(&quot;b_fr&quot;=&gt;[25…
  &quot;data_model&quot;     =&gt; ENGINEERING</pre><p>╔═╡ c884fd5b-4ecb-402b-b228-01b9a61db8bf</p><pre><code class="language-julia">md&quot;&quot;&quot;
Different information and warning messages will be given depending on the input file. In the case above, these messages all related to various parse notifications that arise during a parse of a dss file, and can be safely ignored

The resulting data structure is a Julia dictionary. The first notable field is `&quot;data_model&quot;` which specifies which data model this data structure corresponds to, in this case `ENGINEERING`. This value is expected to be an `Enum` of type `DataModel`

The next notable field is `&quot;settings&quot;`, which contains some important default/starting values for the distribution network
&quot;&quot;&quot;</code></pre><div class="markdown"><p>Different information and warning messages will be given depending on the input file. In the case above, these messages all related to various parse notifications that arise during a parse of a dss file, and can be safely ignored</p>
<p>The resulting data structure is a Julia dictionary. The first notable field is <code>&quot;data_model&quot;</code> which specifies which data model this data structure corresponds to, in this case <code>ENGINEERING</code>. This value is expected to be an <code>Enum</code> of type <code>DataModel</code></p>
<p>The next notable field is <code>&quot;settings&quot;</code>, which contains some important default/starting values for the distribution network</p>
</div><p>╔═╡ a5b736f9-2776-4760-b073-d02027baef13</p><pre><code class="language-julia">eng[&quot;settings&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 5 entries:
  &quot;sbase_default&quot;        =&gt; 500.0
  &quot;vbases_default&quot;       =&gt; Dict(&quot;sourcebus&quot;=&gt;0.23094)
  &quot;voltage_scale_factor&quot; =&gt; 1000.0
  &quot;power_scale_factor&quot;   =&gt; 1000.0
  &quot;base_frequency&quot;       =&gt; 50.0</pre><p>╔═╡ 29a8a560-7d5e-4929-877a-2dab17309968</p><pre><code class="language-julia">md&quot;&quot;&quot;
- `&quot;sbase_default&quot;` is the starting value for the power base,
- `&quot;vbases_default&quot;` is the starting voltage base for the case, and multiple voltage bases can be specified, which would be useful in cases where there are multiple isolated islands with their own generation,
- `&quot;voltage_scale_factor&quot;` is a scaling factor for all voltage values, which in the case of OpenDSS is in kV by default
- `&quot;power_scale_factor&quot;` is a scaling factor for all power values
- `&quot;base_frequency&quot;` is the base frequency of the network in Hz, which is useful to know for mixed frequency networks

Next we look at the `&quot;bus&quot;` components
&quot;&quot;&quot;</code></pre><div class="markdown"><ul>
<li><p><code>&quot;sbase_default&quot;</code> is the starting value for the power base,</p>
</li>
<li><p><code>&quot;vbases_default&quot;</code> is the starting voltage base for the case, and multiple voltage bases can be specified, which would be useful in cases where there are multiple isolated islands with their own generation,</p>
</li>
<li><p><code>&quot;voltage_scale_factor&quot;</code> is a scaling factor for all voltage values, which in the case of OpenDSS is in kV by default</p>
</li>
<li><p><code>&quot;power_scale_factor&quot;</code> is a scaling factor for all power values</p>
</li>
<li><p><code>&quot;base_frequency&quot;</code> is the base frequency of the network in Hz, which is useful to know for mixed frequency networks</p>
</li>
</ul>
<p>Next we look at the <code>&quot;bus&quot;</code> components</p>
</div><p>╔═╡ 9ac6b0ed-58a8-4079-aa9f-d70024f4d4b4</p><pre><code class="language-julia">eng[&quot;bus&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 3 entries:
  &quot;primary&quot;   =&gt; Dict{String, Any}(&quot;rg&quot;=&gt;Float64[], &quot;grounded&quot;=&gt;Int64[], &quot;statu…
  &quot;sourcebus&quot; =&gt; Dict{String, Any}(&quot;rg&quot;=&gt;[0.0], &quot;grounded&quot;=&gt;[4], &quot;status&quot;=&gt;ENAB…
  &quot;loadbus&quot;   =&gt; Dict{String, Any}(&quot;rg&quot;=&gt;[0.0], &quot;grounded&quot;=&gt;[4], &quot;status&quot;=&gt;ENAB…</pre><p>╔═╡ 89846878-ebfc-49a5-91ef-762f692ba5ea</p><pre><code class="language-julia">md&quot;&quot;&quot;
We can see there are three buses in this system, identified by ids `&quot;primary&quot;`, `&quot;sourcebus&quot;`, and `&quot;loadbus&quot;`.

__NOTE__: In Julia, order of Dictionary keys is not fixed, nor does it retain the order in which it was parsed like _e.g._ `Vectors`.

Identifying components by non-integer names is a new feature of the `ENGINEERING` model, and makes network debugging more straightforward.

__NOTE__: all names are converted to lowercase on parse from the originating dss file.

Each bus component has the following properties in the `ENGINEERING` model
&quot;&quot;&quot;</code></pre><div class="markdown"><p>We can see there are three buses in this system, identified by ids <code>&quot;primary&quot;</code>, <code>&quot;sourcebus&quot;</code>, and <code>&quot;loadbus&quot;</code>.</p>
<p><strong>NOTE</strong>: In Julia, order of Dictionary keys is not fixed, nor does it retain the order in which it was parsed like <em>e.g.</em> <code>Vectors</code>.</p>
<p>Identifying components by non-integer names is a new feature of the <code>ENGINEERING</code> model, and makes network debugging more straightforward.</p>
<p><strong>NOTE</strong>: all names are converted to lowercase on parse from the originating dss file.</p>
<p>Each bus component has the following properties in the <code>ENGINEERING</code> model</p>
</div><p>╔═╡ 8ba081b4-8444-48e0-afce-20649f7fdd01</p><pre><code class="language-julia">eng[&quot;bus&quot;][&quot;sourcebus&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 5 entries:
  &quot;rg&quot;        =&gt; [0.0]
  &quot;grounded&quot;  =&gt; [4]
  &quot;status&quot;    =&gt; ENABLED
  &quot;terminals&quot; =&gt; [1, 2, 3, 4]
  &quot;xg&quot;        =&gt; [0.0]</pre><p>╔═╡ 2a8c1536-ef5f-4e37-b30e-1bb73982d7b0</p><pre><code class="language-julia">md&quot;&quot;&quot;
- `&quot;terminals&quot;` indicates which terminals on the bus have active connections
- `&quot;grounded&quot;` indicates which terminals are grounded
- `&quot;rg&quot;` and `&quot;xg&quot;` indicate the grounding resistance and reactance of the ground
- `&quot;status&quot;` indicates whether a bus is `ENABLED` or `DISABLED`, and is specified for every component in the engineering model

Next, we look at the `&quot;line&quot;` components, which is a generic name for both overhead lines and underground cables, which we do not differentiate between in the nomenclature
&quot;&quot;&quot;</code></pre><div class="markdown"><ul>
<li><p><code>&quot;terminals&quot;</code> indicates which terminals on the bus have active connections</p>
</li>
<li><p><code>&quot;grounded&quot;</code> indicates which terminals are grounded</p>
</li>
<li><p><code>&quot;rg&quot;</code> and <code>&quot;xg&quot;</code> indicate the grounding resistance and reactance of the ground</p>
</li>
<li><p><code>&quot;status&quot;</code> indicates whether a bus is <code>ENABLED</code> or <code>DISABLED</code>, and is specified for every component in the engineering model</p>
</li>
</ul>
<p>Next, we look at the <code>&quot;line&quot;</code> components, which is a generic name for both overhead lines and underground cables, which we do not differentiate between in the nomenclature</p>
</div><p>╔═╡ 83ce434c-0f92-46a8-8648-322084044600</p><pre><code class="language-julia">eng[&quot;line&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 2 entries:
  &quot;quad&quot;   =&gt; Dict{String, Any}(&quot;cm_ub&quot;=&gt;[400.0, 400.0, 400.0], &quot;cm_ub_c&quot;=&gt;[600…
  &quot;ohline&quot; =&gt; Dict{String, Any}(&quot;cm_ub&quot;=&gt;[400.0, 400.0, 400.0], &quot;cm_ub_c&quot;=&gt;[600…</pre><p>╔═╡ 2f9c3f64-3e5d-423f-939e-8d96bd19e7fe</p><pre><code class="language-julia">eng[&quot;line&quot;][&quot;quad&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 11 entries:
  &quot;cm_ub&quot;         =&gt; [400.0, 400.0, 400.0]
  &quot;cm_ub_c&quot;       =&gt; [600.0, 600.0, 600.0]
  &quot;f_connections&quot; =&gt; [1, 2, 3]
  &quot;length&quot;        =&gt; 1.0
  &quot;status&quot;        =&gt; ENABLED
  &quot;source_id&quot;     =&gt; &quot;line.quad&quot;
  &quot;t_connections&quot; =&gt; [1, 2, 3]
  &quot;f_bus&quot;         =&gt; &quot;primary&quot;
  &quot;t_bus&quot;         =&gt; &quot;loadbus&quot;
  &quot;cm_ub_b&quot;       =&gt; [600.0, 600.0, 600.0]
  &quot;linecode&quot;      =&gt; &quot;4/0quad&quot;</pre><p>╔═╡ f06b9592-0e16-4fd1-bf6e-624ec0cdb8fb</p><pre><code class="language-julia">md&quot;&quot;&quot;
Again, we see components identified by their OpenDSS names. A `&quot;line&quot;` is an edge object, which will always have the following properties:

- `&quot;f_bus&quot;`
- `&quot;t_bus&quot;`
- `&quot;f_connections&quot;` - list of terminals to which the line is connected on the from-side
- `&quot;t_connections&quot;` - list of terminals to which the line is connected on the to-side

Here we are also introduced to two important concepts, the `&quot;source_id&quot;`, which is an easy way to identify from where an object originates in the dss file, and a data type element, pointed to by `&quot;linecode&quot;` in this case.

A data type element is an element that does not represent a real engineering object, but only contains data that one of those real objects can refer to, in this case a linecode, which contains information like line resistance/reactance and conductance/susceptance.
&quot;&quot;&quot;</code></pre><div class="markdown"><p>Again, we see components identified by their OpenDSS names. A <code>&quot;line&quot;</code> is an edge object, which will always have the following properties:</p>
<ul>
<li><p><code>&quot;f_bus&quot;</code></p>
</li>
<li><p><code>&quot;t_bus&quot;</code></p>
</li>
<li><p><code>&quot;f_connections&quot;</code> - list of terminals to which the line is connected on the from-side</p>
</li>
<li><p><code>&quot;t_connections&quot;</code> - list of terminals to which the line is connected on the to-side</p>
</li>
</ul>
<p>Here we are also introduced to two important concepts, the <code>&quot;source_id&quot;</code>, which is an easy way to identify from where an object originates in the dss file, and a data type element, pointed to by <code>&quot;linecode&quot;</code> in this case.</p>
<p>A data type element is an element that does not represent a real engineering object, but only contains data that one of those real objects can refer to, in this case a linecode, which contains information like line resistance/reactance and conductance/susceptance.</p>
</div><p>╔═╡ b15593b9-f775-47af-aa9b-4980a4028faa</p><pre><code class="language-julia">eng[&quot;linecode&quot;][&quot;4/0quad&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 6 entries:
  &quot;b_fr&quot; =&gt; [25.4648 -0.0 -0.0; -0.0 25.4648 -0.0; -0.0 -0.0 25.4648]
  &quot;rs&quot;   =&gt; [0.1167 0.0467 0.0467; 0.0467 0.1167 0.0467; 0.0467 0.0467 0.1167]
  &quot;xs&quot;   =&gt; [0.0667 0.0267 0.0267; 0.0267 0.0667 0.0267; 0.0267 0.0267 0.0667]
  &quot;b_to&quot; =&gt; [25.4648 -0.0 -0.0; -0.0 25.4648 -0.0; -0.0 -0.0 25.4648]
  &quot;g_to&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]
  &quot;g_fr&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]</pre><p>╔═╡ 2e4fe000-449c-4fc0-8707-4c51ac50ab03</p><pre><code class="language-julia">md&quot;&quot;&quot;
We can see that the length of the Vectors for `&quot;pd_nom&quot;` and `&quot;qd_nom&quot;` are only one, although the number of terminals listed in `&quot;connections&quot;` is two. This is because the connection is WYE, and therefore the final connection is a grounded neutral

Here we are also introduced to two new Enums, `WYE`, which gives the connection configuration, and `NO` under dispatchable, which indicates that if this case were used in an MLD problem, _i.e._ with `run_mc_mld` that this load would not be sheddable.

Finally, we show the generation source for this case, which in opendss is a voltage source named `&quot;source&quot;`
&quot;&quot;&quot;</code></pre><div class="markdown"><p>We can see that the length of the Vectors for <code>&quot;pd_nom&quot;</code> and <code>&quot;qd_nom&quot;</code> are only one, although the number of terminals listed in <code>&quot;connections&quot;</code> is two. This is because the connection is WYE, and therefore the final connection is a grounded neutral</p>
<p>Here we are also introduced to two new Enums, <code>WYE</code>, which gives the connection configuration, and <code>NO</code> under dispatchable, which indicates that if this case were used in an MLD problem, <em>i.e.</em> with <code>run_mc_mld</code> that this load would not be sheddable.</p>
<p>Finally, we show the generation source for this case, which in opendss is a voltage source named <code>&quot;source&quot;</code></p>
</div><p>╔═╡ 36ca17bc-b560-48c9-988f-255780479d05</p><pre><code class="language-julia">eng[&quot;voltage_source&quot;][&quot;source&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 8 entries:
  &quot;source_id&quot;   =&gt; &quot;vsource.source&quot;
  &quot;rs&quot;          =&gt; [4.27691e-8 3.96342e-9 3.96342e-9 0.0; 3.96342e-9 4.27691e-8…
  &quot;va&quot;          =&gt; [0.0, -120.0, 120.0, 0.0]
  &quot;status&quot;      =&gt; ENABLED
  &quot;connections&quot; =&gt; [1, 2, 3, 4]
  &quot;vm&quot;          =&gt; [0.229993, 0.229993, 0.229993, 0.0]
  &quot;xs&quot;          =&gt; [1.54178e-7 -1.04497e-9 -1.04497e-9 0.0; -1.04497e-9 1.54178…
  &quot;bus&quot;         =&gt; &quot;sourcebus&quot;</pre><p>╔═╡ 7e5811cf-86a2-43fb-8c94-44091f33c031</p><pre><code class="language-julia">md&quot;&quot;&quot;
- `&quot;vm&quot;` - specifies the fixed voltage magnitudes per phase at the bus
- `&quot;va&quot;` - specifies the fixed reference angles per phases at the bus
- `&quot;rs&quot;` and `&quot;xs&quot;` specifies internal impedances of the voltage source

### Importing raw dss properties

In case there are additional properties that you want to use from dss, it is possible to import those directly into the `ENGINEERING` (and `MATHEMATICAL`) data structure with the `import_all` keyword argument
&quot;&quot;&quot;</code></pre><div class="markdown"><ul>
<li><p><code>&quot;vm&quot;</code> - specifies the fixed voltage magnitudes per phase at the bus</p>
</li>
<li><p><code>&quot;va&quot;</code> - specifies the fixed reference angles per phases at the bus</p>
</li>
<li><p><code>&quot;rs&quot;</code> and <code>&quot;xs&quot;</code> specifies internal impedances of the voltage source</p>
</li>
</ul>
<h3>Importing raw dss properties</h3>
<p>In case there are additional properties that you want to use from dss, it is possible to import those directly into the <code>ENGINEERING</code> &#40;and <code>MATHEMATICAL</code>&#41; data structure with the <code>import_all</code> keyword argument</p>
</div><p>╔═╡ 026088f7-b1df-4647-ad81-52c6c8ea7944</p><pre><code class="language-">eng_all = parse_file(&quot;../test/data/opendss/case3_unbalanced.dss&quot;; import_all=true)</code></pre><p>╔═╡ 5f72ecec-bb3f-4231-93c1-719e38e17be4</p><pre><code class="language-julia">md&quot;&quot;&quot;
You will note the presence of `&quot;dss&quot;` dictionaries under components, and `&quot;dss_options&quot;` at the root level
&quot;&quot;&quot;</code></pre><div class="markdown"><p>You will note the presence of <code>&quot;dss&quot;</code> dictionaries under components, and <code>&quot;dss_options&quot;</code> at the root level</p>
</div><p>╔═╡ f070dbbc-1a55-48f2-aa21-2119eb573b5b</p><pre><code class="language-">eng_all[&quot;line&quot;]</code></pre><p>╔═╡ f3458a5c-70c6-4d0c-8253-4feb0c87ee76</p><pre><code class="language-julia">md&quot;&quot;&quot;
### Time Series Parsing Example

In the `ENGINEERING` model, we have included the `time_series` data type, which holds all time series data and can be referred to similar to `&quot;linecode&quot;` as demonstrated above.

Below we can see an example of a parse that includes some time_series components
&quot;&quot;&quot;</code></pre><div class="markdown"><h3>Time Series Parsing Example</h3>
<p>In the <code>ENGINEERING</code> model, we have included the <code>time_series</code> data type, which holds all time series data and can be referred to similar to <code>&quot;linecode&quot;</code> as demonstrated above.</p>
<p>Below we can see an example of a parse that includes some time_series components</p>
</div><p>╔═╡ 542e592f-8f75-41f9-8f98-5373b431fcc6</p><pre><code class="language-">eng_ts = parse_file(&quot;../test/data/opendss/case3_balanced.dss&quot;; time_series=&quot;daily&quot;)</code></pre><p>╔═╡ d0e02ee5-f57c-4286-940d-b01097c840be</p><pre><code class="language-julia">md&quot;&quot;&quot;
You can see that under the actual component, in this case a `&quot;load&quot;`, that there is a `&quot;time_series&quot;` dictionary that contains `ENGINEERING` model variable names and references to the identifiers of a root-level `time_series` object,
&quot;&quot;&quot;</code></pre><div class="markdown"><p>You can see that under the actual component, in this case a <code>&quot;load&quot;</code>, that there is a <code>&quot;time_series&quot;</code> dictionary that contains <code>ENGINEERING</code> model variable names and references to the identifiers of a root-level <code>time_series</code> object,</p>
</div><p>╔═╡ e852712c-d09a-41e1-9785-308c219c7ad8</p><pre><code class="language-">eng_ts[&quot;time_series&quot;][&quot;ls1&quot;]</code></pre><p>╔═╡ 0eba403e-c2ba-4af3-8dcc-fe14a3c22bd7</p><pre><code class="language-julia">md&quot;&quot;&quot;
This feature is useful for building multinetwork data structures, which will be described below in the section on the `MATHEMATICAL` model
&quot;&quot;&quot;</code></pre><div class="markdown"><p>This feature is useful for building multinetwork data structures, which will be described below in the section on the <code>MATHEMATICAL</code> model</p>
</div><p>╔═╡ 8d5701d1-9e91-43b5-975b-fc8e0e306e99</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Running Optimal Power Flow

In this section we introduce how to run an optimal power flow (opf) in PowerModelsDistribution on an engineering data model

In order to run an OPF problem you will need

1. a data model
2. a formulation
3. a solver

In these examples we will use the `eng` model we worked with above, the `ACPUPowerModel`, which is a AC power flow formulation in polar coordinates, and the `ipopt_solver` we already defined above
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Running Optimal Power Flow</h1>
<p>In this section we introduce how to run an optimal power flow &#40;opf&#41; in PowerModelsDistribution on an engineering data model</p>
<p>In order to run an OPF problem you will need</p>
<ol>
<li><p>a data model</p>
</li>
<li><p>a formulation</p>
</li>
<li><p>a solver</p>
</li>
</ol>
<p>In these examples we will use the <code>eng</code> model we worked with above, the <code>ACPUPowerModel</code>, which is a AC power flow formulation in polar coordinates, and the <code>ipopt_solver</code> we already defined above</p>
</div><p>╔═╡ 745f33bf-98d7-4b27-95fd-ec6bf5e3d5cf</p><pre><code class="language-julia">result = solve_mc_opf(eng, ACPUPowerModel, ipopt_solver)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 8 entries:
  &quot;solve_time&quot;         =&gt; 3.3549
  &quot;optimizer&quot;          =&gt; &quot;Ipopt&quot;
  &quot;termination_status&quot; =&gt; LOCALLY_SOLVED
  &quot;dual_status&quot;        =&gt; FEASIBLE_POINT
  &quot;primal_status&quot;      =&gt; FEASIBLE_POINT
  &quot;objective&quot;          =&gt; 0.0214812
  &quot;solution&quot;           =&gt; Dict{String, Any}(&quot;voltage_source&quot;=&gt;Dict{String, Any}…
  &quot;objective_lb&quot;       =&gt; -Inf</pre><p>╔═╡ fb81d3c1-a47b-46d9-b463-1766022be114</p><pre><code class="language-julia">md&quot;&quot;&quot;
The result of `solve_mc_opf` will be very familiar to those who are already familiar with PowerModels and PowerModelsDistribution. The notable difference will be in the `&quot;solution&quot;` dictionary
&quot;&quot;&quot;</code></pre><div class="markdown"><p>The result of <code>solve_mc_opf</code> will be very familiar to those who are already familiar with PowerModels and PowerModelsDistribution. The notable difference will be in the <code>&quot;solution&quot;</code> dictionary</p>
</div><p>╔═╡ 27d5a237-4c2e-4b14-a082-f4847153c8d5</p><pre><code class="language-julia">result[&quot;solution&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 6 entries:
  &quot;voltage_source&quot; =&gt; Dict{String, Any}(&quot;source&quot;=&gt;Dict{String, Any}(&quot;qg_bus&quot;=&gt;[…
  &quot;line&quot;           =&gt; Dict{String, Any}(&quot;quad&quot;=&gt;Dict{String, Any}(&quot;qf&quot;=&gt;[3.0948…
  &quot;settings&quot;       =&gt; Dict{String, Any}(&quot;sbase_default&quot;=&gt;500.0, &quot;vbases_default…
  &quot;load&quot;           =&gt; Dict{String, Any}(&quot;l2&quot;=&gt;Dict{String, Any}(&quot;qd_bus&quot;=&gt;[3.0]…
  &quot;bus&quot;            =&gt; Dict{String, Any}(&quot;primary&quot;=&gt;Dict{String, Any}(&quot;va&quot;=&gt;[-0.…
  &quot;per_unit&quot;       =&gt; false</pre><p>╔═╡ 564200e0-2080-44da-8dbf-37c5e3a38412</p><pre><code class="language-julia">md&quot;&quot;&quot;
Here you can see that the solution comes back out by default into the same data model as is provided by the user to the run_ command, as well as being in SI units, as opposed to per unit, which is used during the solve. For example,
&quot;&quot;&quot;</code></pre><div class="markdown"><p>Here you can see that the solution comes back out by default into the same data model as is provided by the user to the run_ command, as well as being in SI units, as opposed to per unit, which is used during the solve. For example,</p>
</div><p>╔═╡ 8b066039-ed65-4617-b404-86952d3fc78e</p><pre><code class="language-julia">result[&quot;solution&quot;][&quot;bus&quot;][&quot;loadbus&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 2 entries:
  &quot;va&quot; =&gt; [-0.484238, -120.243, 120.274]
  &quot;vm&quot; =&gt; [0.222521, 0.226727, 0.225577]</pre><p>╔═╡ a09de8ab-c1e1-4c9f-9d86-4268ce503cae</p><pre><code class="language-julia">md&quot;&quot;&quot;
If for some reason you want to return the result in per-unit rather than SI, you can specify this in the `solve_` command by
&quot;&quot;&quot;</code></pre><div class="markdown"><p>If for some reason you want to return the result in per-unit rather than SI, you can specify this in the <code>solve_</code> command by</p>
</div><p>╔═╡ 763a1504-f927-4dfc-a042-ac66324708a9</p><pre><code class="language-julia">result_pu = solve_mc_opf(eng, ACPUPowerModel, ipopt_solver; make_si=false)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 8 entries:
  &quot;solve_time&quot;         =&gt; 0.00716996
  &quot;optimizer&quot;          =&gt; &quot;Ipopt&quot;
  &quot;termination_status&quot; =&gt; LOCALLY_SOLVED
  &quot;dual_status&quot;        =&gt; FEASIBLE_POINT
  &quot;primal_status&quot;      =&gt; FEASIBLE_POINT
  &quot;objective&quot;          =&gt; 0.0214812
  &quot;solution&quot;           =&gt; Dict{String, Any}(&quot;voltage_source&quot;=&gt;Dict{String, Any}…
  &quot;objective_lb&quot;       =&gt; -Inf</pre><p>╔═╡ e7b588e9-fb5f-4383-b5c6-bce9ed8f5a60</p><pre><code class="language-julia">result_pu[&quot;solution&quot;][&quot;bus&quot;][&quot;loadbus&quot;]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 2 entries:
  &quot;va&quot; =&gt; [-0.484238, -120.243, 120.274]
  &quot;vm&quot; =&gt; [0.963546, 0.981757, 0.976779]</pre><p>╔═╡ f882f070-74af-4f3b-9ad1-bd7ad453778f</p><pre><code class="language-julia">md&quot;&quot;&quot;
### Branch Flow formulations

Previously, to use a branch flow formulation, such as `SOCNLPUBFPowerModel`, it was required to use a different `solve_` command, but now, by using multiple dispatch we have simplified this for the user
&quot;&quot;&quot;</code></pre><div class="markdown"><h3>Branch Flow formulations</h3>
<p>Previously, to use a branch flow formulation, such as <code>SOCNLPUBFPowerModel</code>, it was required to use a different <code>solve_</code> command, but now, by using multiple dispatch we have simplified this for the user</p>
</div><p>╔═╡ f2fa779e-f62d-4053-b055-e9f0aee6c3f7</p><pre><code class="language-julia">result_bf = solve_mc_opf(eng, SOCNLPUBFPowerModel, ipopt_solver)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 8 entries:
  &quot;solve_time&quot;         =&gt; 0.263578
  &quot;optimizer&quot;          =&gt; &quot;Ipopt&quot;
  &quot;termination_status&quot; =&gt; LOCALLY_SOLVED
  &quot;dual_status&quot;        =&gt; FEASIBLE_POINT
  &quot;primal_status&quot;      =&gt; FEASIBLE_POINT
  &quot;objective&quot;          =&gt; 0.0211305
  &quot;solution&quot;           =&gt; Dict{String, Any}(&quot;voltage_source&quot;=&gt;Dict{String, Any}…
  &quot;objective_lb&quot;       =&gt; -Inf</pre><p>╔═╡ 544108d1-d1a7-4dc6-9a3c-6a10025cb8a3</p><pre><code class="language-julia">md&quot;&quot;&quot;
### Running Time Series Models

By default, `time_series` object will be ignored when running a model. To use the time series information you will need to have a multinetwork problem specification

In the example below we use a test case, which is not exported by default, and therefore requires the specification of the PowerModelsDistribution namespace
&quot;&quot;&quot;</code></pre><div class="markdown"><h3>Running Time Series Models</h3>
<p>By default, <code>time_series</code> object will be ignored when running a model. To use the time series information you will need to have a multinetwork problem specification</p>
<p>In the example below we use a test case, which is not exported by default, and therefore requires the specification of the PowerModelsDistribution namespace</p>
</div><p>╔═╡ ae8daf6c-4055-497e-905c-d6d5a6373ad3</p><pre><code class="language-">result_mn = PowerModelsDistribution._solve_mn_mc_opb(eng_ts, NFAUPowerModel, ipopt_solver)</code></pre><p>╔═╡ 3d86989a-a4db-4766-aec7-abc9a25ffde8</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Engineering Model Transformations

One of the power things about the engineering model is that data transformations are much more simple. Here we illustrate two examples that are currently included in PowerModelsDistribution, but writing your own data transformation functions will be trivial, as we will show.

__Note__: In v0.9, `apply_kron_reduction!` and `apply_phase_projection!` are applied by default, but can be disabled with the keyword arguments `kron_reduced=false` and `project_phases=false`, respectively in `parse_file` or `transform_data_model`.

First, there are several objects that have loss models by default when parsing from dss files, such as voltage sources, transformers, and switches. To remove these loss models, therefore making these components lossless, we can use the included `make_lossess!` function. Here we use a basic 2-winding wye-wye connected transformer case from `test` to illustrate this
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Engineering Model Transformations</h1>
<p>One of the power things about the engineering model is that data transformations are much more simple. Here we illustrate two examples that are currently included in PowerModelsDistribution, but writing your own data transformation functions will be trivial, as we will show.</p>
<p><strong>Note</strong>: In v0.9, <code>apply_kron_reduction&#33;</code> and <code>apply_phase_projection&#33;</code> are applied by default, but can be disabled with the keyword arguments <code>kron_reduced&#61;false</code> and <code>project_phases&#61;false</code>, respectively in <code>parse_file</code> or <code>transform_data_model</code>.</p>
<p>First, there are several objects that have loss models by default when parsing from dss files, such as voltage sources, transformers, and switches. To remove these loss models, therefore making these components lossless, we can use the included <code>make_lossess&#33;</code> function. Here we use a basic 2-winding wye-wye connected transformer case from <code>test</code> to illustrate this</p>
</div><p>╔═╡ 7a86e26d-fdf6-41b6-b1dd-dc0c4a8e9d50</p><pre><code class="language-">eng_ut = parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;)</code></pre><p>╔═╡ 82e9330b-2e94-42a1-b56d-430674b11241</p><pre><code class="language-">eng_ut[&quot;transformer&quot;][&quot;tx1&quot;]</code></pre><p>╔═╡ 2c358d7a-5d84-4f62-a147-577bb775ac7f</p><pre><code class="language-julia">md&quot;&quot;&quot;
We can see that &quot;noloadloss&quot;, &quot;rw&quot;, and &quot;imag&quot; are non-zero, but if we apply the make_lossless! function we can see these parameters are set to zero, effectively eliminating the losses
&quot;&quot;&quot;</code></pre><div class="markdown"><p>We can see that &quot;noloadloss&quot;, &quot;rw&quot;, and &quot;imag&quot; are non-zero, but if we apply the make_lossless&#33; function we can see these parameters are set to zero, effectively eliminating the losses</p>
</div><p>╔═╡ 5e5dd24c-95b5-4951-8547-13e20bb0feec</p><pre><code class="language-">make_lossless!(eng_ut)</code></pre><p>╔═╡ 45c320dd-e0b2-46ec-af09-d83e5652026d</p><pre><code class="language-">eng_ut[&quot;transformer&quot;][&quot;tx1&quot;]</code></pre><p>╔═╡ 723f4e26-8065-4e22-8c5c-de32d2e42b47</p><pre><code class="language-julia">md&quot;Alternatively, we can apply this function at parse&quot;</code></pre><div class="markdown"><p>Alternatively, we can apply this function at parse</p>
</div><p>╔═╡ 58f80651-4a44-4781-a6c0-a056ec76b07e</p><pre><code class="language-">parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;; transformations=[make_lossless!])</code></pre><p>╔═╡ b1e55263-9c76-43b2-b91c-115b2f080182</p><pre><code class="language-julia">md&quot;&quot;&quot;
Another transformation function included in PowerModelsDistribution is the `apply_voltage_bounds!` function, which will apply some voltage bounds in SI units, given some percent value, _e.g._ if we want the lower bound on voltage to be `0.9` and upper bound `1.1` after per-unit conversion
&quot;&quot;&quot;</code></pre><div class="markdown"><p>Another transformation function included in PowerModelsDistribution is the <code>apply_voltage_bounds&#33;</code> function, which will apply some voltage bounds in SI units, given some percent value, <em>e.g.</em> if we want the lower bound on voltage to be <code>0.9</code> and upper bound <code>1.1</code> after per-unit conversion</p>
</div><p>╔═╡ 2cdd682a-b97f-49dc-8829-47e7146497b9</p><pre><code class="language-">apply_voltage_bounds!(eng_ut; vm_lb=0.9, vm_ub=1.1)</code></pre><p>╔═╡ 74836b2c-db67-4435-a552-ba5c3e93e43f</p><pre><code class="language-">eng_ut[&quot;bus&quot;][&quot;2&quot;]</code></pre><p>╔═╡ 2bf802e2-f769-48db-adef-a5a066c565c2</p><pre><code class="language-julia">md&quot;Alternatively, this can be specified at parse by&quot;</code></pre><div class="markdown"><p>Alternatively, this can be specified at parse by</p>
</div><p>╔═╡ 4020d67a-4a9e-4030-b7cd-e5d60e78495c</p><pre><code class="language-">parse_file(&quot;../test/data/opendss/ut_trans_2w_yy.dss&quot;; transformations=[make_lossless!, (apply_voltage_bounds!, &quot;vm_lb&quot;=&gt;0.9, &quot;vm_ub&quot;=&gt;1.1)])</code></pre><p>╔═╡ dde2da59-63fa-4549-8829-491e5f3c675e</p><pre><code class="language-julia">md&quot;&quot;&quot;
### Transformations on Multinetworks

Transformations on Multinetworks should happen __before__ the network is converted into a `MATHEMATICAL` data model, so that they can generally follow the same pattern as shown above and can be seen in the `make_lossless!` and `apply_voltage_bounds!` functions already in PowerModelsDistribution
&quot;&quot;&quot;</code></pre><div class="markdown"><h3>Transformations on Multinetworks</h3>
<p>Transformations on Multinetworks should happen <strong>before</strong> the network is converted into a <code>MATHEMATICAL</code> data model, so that they can generally follow the same pattern as shown above and can be seen in the <code>make_lossless&#33;</code> and <code>apply_voltage_bounds&#33;</code> functions already in PowerModelsDistribution</p>
</div><p>╔═╡ 2c375878-f16b-4833-9aaa-b826fbe056a2</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Mathematical Model

In this section we introduce the mathematical model, which was the previous user-facing model in PowerModelsDistribution, explain how conversions between the model happen in practice, and give an example of how to do this conversion manually

In practice, unless the user is interested, the conversion between the `ENGINEERING` and `MATHEMATICAL` models should be seemless and invisible to the user. By providing an `ENGINEERING` model to a `run_` command the `run_mc_model` command will know to convert the model to `MATHEMATICAL`, which will be used to the generate the JuMP model that will actually be optimized. Similarly, the solution generated by this optimization will be automatically converted back to the format of the `ENGINEERING` model.

Let&#39;s first take a look at how to convert to the `MATHEMATICAL` model
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Mathematical Model</h1>
<p>In this section we introduce the mathematical model, which was the previous user-facing model in PowerModelsDistribution, explain how conversions between the model happen in practice, and give an example of how to do this conversion manually</p>
<p>In practice, unless the user is interested, the conversion between the <code>ENGINEERING</code> and <code>MATHEMATICAL</code> models should be seemless and invisible to the user. By providing an <code>ENGINEERING</code> model to a <code>run_</code> command the <code>run_mc_model</code> command will know to convert the model to <code>MATHEMATICAL</code>, which will be used to the generate the JuMP model that will actually be optimized. Similarly, the solution generated by this optimization will be automatically converted back to the format of the <code>ENGINEERING</code> model.</p>
<p>Let&#39;s first take a look at how to convert to the <code>MATHEMATICAL</code> model</p>
</div><p>╔═╡ a7348fc8-b25e-4ecf-9fe6-314036b7df9c</p><pre><code class="language-julia">math = transform_data_model(eng)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 17 entries:
  &quot;is_kron_reduced&quot; =&gt; true
  &quot;conductor_ids&quot;   =&gt; [1, 2, 3]
  &quot;bus&quot;             =&gt; Dict{String, Any}(&quot;4&quot;=&gt;Dict{String, Any}(&quot;source_id&quot;=&gt;&quot;v…
  &quot;name&quot;            =&gt; &quot;3bus_example&quot;
  &quot;map&quot;             =&gt; Dict{String, Any}[Dict(&quot;unmap_function&quot;=&gt;&quot;_map_math2eng_…
  &quot;settings&quot;        =&gt; Dict{String, Any}(&quot;sbase_default&quot;=&gt;500.0, &quot;vbases_defaul…
  &quot;gen&quot;             =&gt; Dict{String, Any}(&quot;1&quot;=&gt;Dict{String, Any}(&quot;pg&quot;=&gt;[0.0, 0.0…
  &quot;branch&quot;          =&gt; Dict{String, Any}(&quot;1&quot;=&gt;Dict{String, Any}(&quot;br_r&quot;=&gt;[1.0940…
  &quot;storage&quot;         =&gt; Dict{String, Any}()
  &quot;switch&quot;          =&gt; Dict{String, Any}()
  &quot;is_projected&quot;    =&gt; true
  &quot;per_unit&quot;        =&gt; true
  &quot;data_model&quot;      =&gt; MATHEMATICAL
  &quot;bus_lookup&quot;      =&gt; Dict{Any, Int64}(&quot;primary&quot;=&gt;1, &quot;sourcebus&quot;=&gt;2, &quot;loadbus&quot;…
  &quot;shunt&quot;           =&gt; Dict{String, Any}()
  &quot;transformer&quot;     =&gt; Dict{String, Any}()
  &quot;load&quot;            =&gt; Dict{String, Any}(&quot;1&quot;=&gt;Dict{String, Any}(&quot;model&quot;=&gt;POWER,…</pre><p>╔═╡ 54280696-beec-47ee-8114-ea9311aca9eb</p><pre><code class="language-julia">md&quot;&quot;&quot;
There are a couple of things to notice right away. First, the data model transform automatically converts the model to per-unit. Second, there are a lot of empty component sets, whereas in the `ENGINEERING` model, only component types that had components in them were listed. In the `MATHEMATICAL` model certain component dictionaries are always expected to exist, and the `eng2math` conversion functions will automatically populate these.

Next, there are a few unusal fields, such as `&quot;settings&quot;`, which previously didn&#39;t exist in the `MATHEMATICAL` model. This is used for the per-unit conversion specifically in PowerModelsDistribution. Also, is the `&quot;map&quot;` field, which is a `Vector` of Dictionaries that enable the conversion back to `ENGINEERING` from `MATHEMATICAL`. Without this it would be impossible to convert back, and in fact only the solution can be converted, because some properties are combined destructively during the conversion to the `MATHEMATICAL` model, and therefore cannot be reverse engineered. However, since the conversion to `MATHEMATICAL` is not in-place, you will always have a copy of `eng` alongside `math`.

Here is an example of one of the `&quot;map&quot;` entries
&quot;&quot;&quot;</code></pre><div class="markdown"><p>There are a couple of things to notice right away. First, the data model transform automatically converts the model to per-unit. Second, there are a lot of empty component sets, whereas in the <code>ENGINEERING</code> model, only component types that had components in them were listed. In the <code>MATHEMATICAL</code> model certain component dictionaries are always expected to exist, and the <code>eng2math</code> conversion functions will automatically populate these.</p>
<p>Next, there are a few unusal fields, such as <code>&quot;settings&quot;</code>, which previously didn&#39;t exist in the <code>MATHEMATICAL</code> model. This is used for the per-unit conversion specifically in PowerModelsDistribution. Also, is the <code>&quot;map&quot;</code> field, which is a <code>Vector</code> of Dictionaries that enable the conversion back to <code>ENGINEERING</code> from <code>MATHEMATICAL</code>. Without this it would be impossible to convert back, and in fact only the solution can be converted, because some properties are combined destructively during the conversion to the <code>MATHEMATICAL</code> model, and therefore cannot be reverse engineered. However, since the conversion to <code>MATHEMATICAL</code> is not in-place, you will always have a copy of <code>eng</code> alongside <code>math</code>.</p>
<p>Here is an example of one of the <code>&quot;map&quot;</code> entries</p>
</div><p>╔═╡ 1dc06007-b413-4cbb-b43b-2c7955ecb6d2</p><pre><code class="language-julia">math[&quot;map&quot;][end]</code></pre><pre class="documenter-example-output">Dict{String, Any} with 3 entries:
  &quot;to&quot;             =&gt; [&quot;gen.1&quot;, &quot;bus.4&quot;, &quot;branch.3&quot;]
  &quot;from&quot;           =&gt; &quot;source&quot;
  &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_voltage_source!&quot;</pre><p>╔═╡ 96a65bdc-7ee4-4e9f-94f5-8a83f7512fe9</p><pre><code class="language-julia">md&quot;&quot;&quot;
Alternatively, the `MATHEMATICAL` model can be returned directly from the `parse_file` command with the `data_model` keyword argument
&quot;&quot;&quot;</code></pre><div class="markdown"><p>Alternatively, the <code>MATHEMATICAL</code> model can be returned directly from the <code>parse_file</code> command with the <code>data_model</code> keyword argument</p>
</div><p>╔═╡ 545c9270-257a-46e8-970d-6a9fcf09dc17</p><pre><code class="language-">parse_file(&quot;../test/data/opendss/case3_unbalanced.dss&quot;; data_model=MATHEMATICAL)</code></pre><p>╔═╡ fda420a1-e563-4a41-84d4-2a570bf163ae</p><pre><code class="language-">md&quot;&quot;&quot;
### Multinetworks

In this subsection we cover parsing into a multinetwork data structure, which is a structure that only exists in the `MATHEMATICAL` model

For those unfamiliar, the InfrastructureModels family of packages has a feature called multinetworks, which is useful for, among other things, running optimization problems on time series type problems.

Multinetwork data structures are formatted like so
</code></pre><p>julia mn = Dict{String,Any}(     &quot;multinetwork&quot; =&gt; true,     &quot;nw&quot; =&gt; Dict{String,Any}(         &quot;1&quot; =&gt; Dict{String,Any}(             &quot;bus&quot; =&gt; Dict{String,Any}(),             ...         ),         ...     ),     ... )</p><pre><code class="language-none">
To automatically create a multinetwork structure from an engineering model that contains `time_series` elements, we can use the `multinetwork` keyword argument in `transform_data_model`
&quot;&quot;&quot;</code></pre><p>╔═╡ 785a1c39-aa56-4244-b7b9-31d7a31b73c3</p><pre><code class="language-">math_mn = transform_data_model(eng_ts; multinetwork=true)</code></pre><p>╔═╡ ad48b3ad-ede1-4109-9647-007c1d8d196c</p><pre><code class="language-">parse_file(&quot;../test/data/opendss/case3_balanced.dss&quot;; multinetwork=true, data_model=MATHEMATICAL)</code></pre><p>╔═╡ 666223d5-802a-4164-882c-8ab1a1319d6d</p><pre><code class="language-julia">md&quot;&quot;&quot;
### Running `MATHEMATICAL` models

There is very little difference from the user point-of-view in running `MATHEMATICAL` models other than the results will not be automatically converted back to the the format of the `ENGINEERING` model
&quot;&quot;&quot;</code></pre><div class="markdown"><h3>Running <code>MATHEMATICAL</code> models</h3>
<p>There is very little difference from the user point-of-view in running <code>MATHEMATICAL</code> models other than the results will not be automatically converted back to the the format of the <code>ENGINEERING</code> model</p>
</div><p>╔═╡ e3fe0a5e-9431-453d-b7e5-821de624a4ef</p><pre><code class="language-julia">result_math = solve_mc_opf(math, ACPUPowerModel, ipopt_solver)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 8 entries:
  &quot;solve_time&quot;         =&gt; 0.00719094
  &quot;optimizer&quot;          =&gt; &quot;Ipopt&quot;
  &quot;termination_status&quot; =&gt; LOCALLY_SOLVED
  &quot;dual_status&quot;        =&gt; FEASIBLE_POINT
  &quot;primal_status&quot;      =&gt; FEASIBLE_POINT
  &quot;objective&quot;          =&gt; 0.0214812
  &quot;solution&quot;           =&gt; Dict{String, Any}(&quot;branch&quot;=&gt;Dict{String, Any}(&quot;1&quot;=&gt;Di…
  &quot;objective_lb&quot;       =&gt; -Inf</pre><p>╔═╡ 5ab6cd16-3c24-4f60-bdf2-7f48b3e25085</p><pre><code class="language-julia">md&quot;&quot;&quot;
It is also possible to manually convert the solution back to the `ENGINEERING` format, provided you have the __map__
&quot;&quot;&quot;</code></pre><div class="markdown"><p>It is also possible to manually convert the solution back to the <code>ENGINEERING</code> format, provided you have the <strong>map</strong></p>
</div><p>╔═╡ 05360163-4a6f-41da-8fae-070e327c2605</p><pre><code class="language-julia">sol_eng = transform_solution(result_math[&quot;solution&quot;], math)</code></pre><pre class="documenter-example-output">Dict{String, Any} with 6 entries:
  &quot;voltage_source&quot; =&gt; Dict{String, Any}(&quot;source&quot;=&gt;Dict{String, Any}(&quot;qg_bus&quot;=&gt;[…
  &quot;line&quot;           =&gt; Dict{String, Any}(&quot;quad&quot;=&gt;Dict{String, Any}(&quot;qf&quot;=&gt;[3.0948…
  &quot;settings&quot;       =&gt; Dict{String, Any}(&quot;sbase_default&quot;=&gt;500.0, &quot;vbases_default…
  &quot;load&quot;           =&gt; Dict{String, Any}(&quot;l2&quot;=&gt;Dict{String, Any}(&quot;qd_bus&quot;=&gt;[3.0]…
  &quot;bus&quot;            =&gt; Dict{String, Any}(&quot;primary&quot;=&gt;Dict{String, Any}(&quot;va&quot;=&gt;[-0.…
  &quot;per_unit&quot;       =&gt; false</pre><p>╔═╡ b8e01ce2-d7f7-4c73-8230-9fdeecab2c4e</p><pre><code class="language-julia">md&quot;&quot;&quot;
#### Running `MATHEMATICAL` Multinetworks

As with the `ENGINEERING` example of running a multinetwork problem, you will need a multinetwork problem specification, and as with the previous single `MATHEMATICAL` network example above, we only obtain the `MATHEMATICAL` solution, and can transform the solution in the same manner as before
&quot;&quot;&quot;</code></pre><div class="markdown"><h4>Running <code>MATHEMATICAL</code> Multinetworks</h4>
<p>As with the <code>ENGINEERING</code> example of running a multinetwork problem, you will need a multinetwork problem specification, and as with the previous single <code>MATHEMATICAL</code> network example above, we only obtain the <code>MATHEMATICAL</code> solution, and can transform the solution in the same manner as before</p>
</div><p>╔═╡ 96757dde-52be-4930-9bdd-9303bb715e55</p><pre><code class="language-">result_math_mn = PowerModelsDistribution._solve_mn_mc_opb(math_mn, NFAUPowerModel, ipopt_solver)</code></pre><p>╔═╡ 867d8d1d-042a-42ec-843e-56b8ba2db96a</p><pre><code class="language-">sol_eng_mn = transform_solution(result_math_mn[&quot;solution&quot;], math_mn)</code></pre><p>╔═╡ db4d9eb9-e120-4489-a3c2-48c43f2a3c3b</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Building the JuMP Model

In some cases the user will want to directly build the JuMP model, which would traditionally be done with `instantiate_model` from PowerModels. In order to facilitate using the `ENGINEERING` model we have introduced `instantiate_mc_model` to aid in the generation of the JuMP model. `instantiate_mc_model` will automatically convert the data model to MATHEMATICAL if necessary (notifying the user of the conversion), and pass the MATHEMATICAL model off to PowerModels&#39; `instantiate_model` with `ref_add_arcs_transformer!` in `ref_extensions`, which is a required ref extension for PowerModelsDistribution.
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Building the JuMP Model</h1>
<p>In some cases the user will want to directly build the JuMP model, which would traditionally be done with <code>instantiate_model</code> from PowerModels. In order to facilitate using the <code>ENGINEERING</code> model we have introduced <code>instantiate_mc_model</code> to aid in the generation of the JuMP model. <code>instantiate_mc_model</code> will automatically convert the data model to MATHEMATICAL if necessary &#40;notifying the user of the conversion&#41;, and pass the MATHEMATICAL model off to PowerModels&#39; <code>instantiate_model</code> with <code>ref_add_arcs_transformer&#33;</code> in <code>ref_extensions</code>, which is a required ref extension for PowerModelsDistribution.</p>
</div><p>╔═╡ 4603bc56-c402-48af-9715-0722e42d90f7</p><pre><code class="language-julia">pm_eng = instantiate_mc_model(eng, NFAUPowerModel, build_mc_opf)</code></pre><pre class="documenter-example-output">NFAUPowerModel(A JuMP Model
Minimization problem with:
Variables: 12
Objective function type: JuMP.AffExpr
`JuMP.AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 12 constraints
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached., Dict{String, Any}(&quot;is_kron_reduced&quot; =&gt; true, &quot;conductor_ids&quot; =&gt; [1, 2, 3], &quot;bus&quot; =&gt; Dict{String, Any}(&quot;4&quot; =&gt; Dict{String, Any}(&quot;source_id&quot; =&gt; &quot;voltage_source.source&quot;, &quot;grounded&quot; =&gt; Bool[0, 0, 0], &quot;vmin&quot; =&gt; [0.9958999999999999, 0.9958999999999999, 0.9958999999999999], &quot;bus_i&quot; =&gt; 4, &quot;index&quot; =&gt; 4, &quot;name&quot; =&gt; &quot;_virtual_bus.voltage_source.source&quot;, &quot;bus_type&quot; =&gt; 3, &quot;va&quot; =&gt; [0.0, -2.0943951023931953, 2.0943951023931957], &quot;terminals&quot; =&gt; [1, 2, 3], &quot;vm&quot; =&gt; [0.9958999999999999, 0.9958999999999999, 0.9958999999999999]…), &quot;1&quot; =&gt; Dict{String, Any}(&quot;source_id&quot; =&gt; &quot;bus.primary&quot;, &quot;name&quot; =&gt; &quot;primary&quot;, &quot;bus_type&quot; =&gt; 1, &quot;grounded&quot; =&gt; Bool[0, 0, 0], &quot;terminals&quot; =&gt; [1, 2, 3], &quot;vmin&quot; =&gt; [0.0, 0.0, 0.0], &quot;vmax&quot; =&gt; [Inf, Inf, Inf], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;index&quot; =&gt; 1, &quot;bus_i&quot; =&gt; 1…), &quot;2&quot; =&gt; Dict{String, Any}(&quot;source_id&quot; =&gt; &quot;bus.sourcebus&quot;, &quot;name&quot; =&gt; &quot;sourcebus&quot;, &quot;bus_type&quot; =&gt; 1, &quot;grounded&quot; =&gt; Bool[0, 0, 0], &quot;terminals&quot; =&gt; [1, 2, 3], &quot;vmin&quot; =&gt; [0.0, 0.0, 0.0], &quot;vmax&quot; =&gt; [Inf, Inf, Inf], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;index&quot; =&gt; 2, &quot;bus_i&quot; =&gt; 2…), &quot;3&quot; =&gt; Dict{String, Any}(&quot;source_id&quot; =&gt; &quot;bus.loadbus&quot;, &quot;name&quot; =&gt; &quot;loadbus&quot;, &quot;bus_type&quot; =&gt; 1, &quot;grounded&quot; =&gt; Bool[0, 0, 0], &quot;terminals&quot; =&gt; [1, 2, 3], &quot;vmin&quot; =&gt; [0.0, 0.0, 0.0], &quot;vmax&quot; =&gt; [Inf, Inf, Inf], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;index&quot; =&gt; 3, &quot;bus_i&quot; =&gt; 3…)), &quot;name&quot; =&gt; &quot;3bus_example&quot;, &quot;map&quot; =&gt; Dict{String, Any}[Dict(&quot;unmap_function&quot; =&gt; &quot;_map_math2eng_root!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.1&quot;, &quot;from&quot; =&gt; &quot;primary&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.2&quot;, &quot;from&quot; =&gt; &quot;sourcebus&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.3&quot;, &quot;from&quot; =&gt; &quot;loadbus&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;branch.1&quot;, &quot;from&quot; =&gt; &quot;quad&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_line!&quot;), Dict(&quot;to&quot; =&gt; &quot;branch.2&quot;, &quot;from&quot; =&gt; &quot;ohline&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_line!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.1&quot;, &quot;from&quot; =&gt; &quot;l2&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.2&quot;, &quot;from&quot; =&gt; &quot;l3&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.3&quot;, &quot;from&quot; =&gt; &quot;l1&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; [&quot;gen.1&quot;, &quot;bus.4&quot;, &quot;branch.3&quot;], &quot;from&quot; =&gt; &quot;source&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_voltage_source!&quot;)], &quot;settings&quot; =&gt; Dict{String, Any}(&quot;sbase_default&quot; =&gt; 500.0, &quot;vbases_default&quot; =&gt; Dict(&quot;sourcebus&quot; =&gt; 0.23094010767585033), &quot;voltage_scale_factor&quot; =&gt; 1000.0, &quot;sbase&quot; =&gt; 500.0, &quot;power_scale_factor&quot; =&gt; 1000.0, &quot;base_frequency&quot; =&gt; 50.0), &quot;gen&quot; =&gt; Dict{String, Any}(&quot;1&quot; =&gt; Dict{String, Any}(&quot;pg&quot; =&gt; [0.0, 0.0, 0.0], &quot;model&quot; =&gt; 2, &quot;connections&quot; =&gt; [1, 2, 3], &quot;shutdown&quot; =&gt; 0.0, &quot;startup&quot; =&gt; 0.0, &quot;configuration&quot; =&gt; WYE, &quot;name&quot; =&gt; &quot;_virtual_gen.voltage_source.source&quot;, &quot;qg&quot; =&gt; [0.0, 0.0, 0.0], &quot;gen_bus&quot; =&gt; 4, &quot;pmax&quot; =&gt; [Inf, Inf, Inf]…)), &quot;branch&quot; =&gt; Dict{String, Any}(&quot;1&quot; =&gt; Dict{String, Any}(&quot;br_r&quot; =&gt; [1.0940624999999997 0.4378124999999999 0.4378124999999999; 0.4378124999999999 1.0940624999999997 0.4378124999999999; 0.4378124999999999 0.4378124999999999 1.0940624999999997], &quot;f_connections&quot; =&gt; [1, 2, 3], &quot;name&quot; =&gt; &quot;quad&quot;, &quot;br_x&quot; =&gt; [0.6253124999999998 0.2503125 0.2503125; 0.2503125 0.6253124999999998 0.2503125; 0.2503125 0.2503125 0.6253124999999998], &quot;g_to&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], &quot;c_rating_a&quot; =&gt; [0.8, 0.8, 0.8], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;g_fr&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], &quot;source_id&quot; =&gt; &quot;line.quad&quot;, &quot;t_connections&quot; =&gt; [1, 2, 3]…), &quot;2&quot; =&gt; Dict{String, Any}(&quot;br_r&quot; =&gt; [0.9374999999999999 0.37499999999999994 0.37499999999999994; 0.37499999999999994 0.9374999999999999 0.37499999999999994; 0.37499999999999994 0.37499999999999994 0.9374999999999999], &quot;f_connections&quot; =&gt; [1, 2, 3], &quot;name&quot; =&gt; &quot;ohline&quot;, &quot;br_x&quot; =&gt; [0.5465624999999998 0.21843749999999998 0.21843749999999998; 0.21843749999999998 0.5465624999999998 0.21843749999999998; 0.21843749999999998 0.21843749999999998 0.5465624999999998], &quot;g_to&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], &quot;c_rating_a&quot; =&gt; [0.8, 0.8, 0.8], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;g_fr&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], &quot;source_id&quot; =&gt; &quot;line.ohline&quot;, &quot;t_connections&quot; =&gt; [1, 2, 3]…), &quot;3&quot; =&gt; Dict{String, Any}(&quot;source_id&quot; =&gt; &quot;voltage_source.source&quot;, &quot;t_connections&quot; =&gt; [1, 2, 3], &quot;f_bus&quot; =&gt; 4, &quot;tranformer&quot; =&gt; false, &quot;br_r&quot; =&gt; [4.009605012762204e-7 3.7157063721720964e-8 3.7157063721720964e-8; 3.7157063721720964e-8 4.009605012762204e-7 3.7157063721720964e-8; 3.7157063721720964e-8 3.7157063721720964e-8 4.009605012762204e-7], &quot;b_fr&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], &quot;br_status&quot; =&gt; 1, &quot;shift&quot; =&gt; [0.0, 0.0, 0.0], &quot;t_bus&quot; =&gt; 2, &quot;b_to&quot; =&gt; [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]…)), &quot;storage&quot; =&gt; Dict{String, Any}(), &quot;switch&quot; =&gt; Dict{String, Any}()…), Dict{String, Any}(), Dict{String, Any}(), Dict{Symbol, Any}(:it =&gt; Dict{Symbol, Any}(:pmd =&gt; Dict{Symbol, Any}(:nw =&gt; Dict{Int64, Any}(0 =&gt; Dict{Symbol, Any}(:map =&gt; Dict{String, Any}[Dict(&quot;unmap_function&quot; =&gt; &quot;_map_math2eng_root!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.1&quot;, &quot;from&quot; =&gt; &quot;primary&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.2&quot;, &quot;from&quot; =&gt; &quot;sourcebus&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;bus.3&quot;, &quot;from&quot; =&gt; &quot;loadbus&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_bus!&quot;), Dict(&quot;to&quot; =&gt; &quot;branch.1&quot;, &quot;from&quot; =&gt; &quot;quad&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_line!&quot;), Dict(&quot;to&quot; =&gt; &quot;branch.2&quot;, &quot;from&quot; =&gt; &quot;ohline&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_line!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.1&quot;, &quot;from&quot; =&gt; &quot;l2&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.2&quot;, &quot;from&quot; =&gt; &quot;l3&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; &quot;load.3&quot;, &quot;from&quot; =&gt; &quot;l1&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_load!&quot;), Dict(&quot;to&quot; =&gt; [&quot;gen.1&quot;, &quot;bus.4&quot;, &quot;branch.3&quot;], &quot;from&quot; =&gt; &quot;source&quot;, &quot;unmap_function&quot; =&gt; &quot;_map_math2eng_voltage_source!&quot;)], :buspairs =&gt; Dict{NTuple{4, Int64}, Dict{String, Real}}((2, 1, 3, 3) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 2, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf), (1, 3, 2, 2) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 1, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf), (2, 1, 2, 2) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 2, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf), (4, 2, 1, 1) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.9958999999999999, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 3, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; 0.9958999999999999), (4, 2, 3, 3) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.9958999999999999, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 3, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; 0.9958999999999999), (1, 3, 1, 1) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 1, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf), (1, 3, 3, 3) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 1, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf), (4, 2, 2, 2) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.9958999999999999, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 3, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; 0.9958999999999999), (2, 1, 1, 1) =&gt; Dict(&quot;vm_to_min&quot; =&gt; Inf, &quot;vm_fr_min&quot; =&gt; 0.0, &quot;angmin&quot; =&gt; -1.0471975511965976, &quot;branch&quot; =&gt; 2, &quot;angmax&quot; =&gt; 1.0471975511965976, &quot;c_rating_a&quot; =&gt; 0.8, &quot;vm_to_max&quot; =&gt; Inf, &quot;vm_fr_max&quot; =&gt; Inf)), :bus_conns_gen =&gt; Dict(4 =&gt; [(1, [1, 2, 3])], 2 =&gt; [], 3 =&gt; [], 1 =&gt; []), :gen =&gt; Dict{Int64, Any}(1 =&gt; Dict{String, Any}(&quot;pg&quot; =&gt; [0.0, 0.0, 0.0], &quot;model&quot; =&gt; 2, &quot;connections&quot; =&gt; [1, 2, 3], &quot;shutdown&quot; =&gt; 0.0, &quot;startup&quot; =&gt; 0.0, &quot;configuration&quot; =&gt; WYE, &quot;name&quot; =&gt; &quot;_virtual_gen.voltage_source.source&quot;, &quot;qg&quot; =&gt; [0.0, 0.0, 0.0], &quot;gen_bus&quot; =&gt; 4, &quot;pmax&quot; =&gt; [Inf, Inf, Inf]…)), :name =&gt; &quot;3bus_example&quot;, :switch_dispatchable =&gt; Dict{Int64, Any}(), :load =&gt; Dict{Int64, Any}(2 =&gt; Dict{String, Any}(&quot;model&quot; =&gt; POWER, &quot;connections&quot; =&gt; [3], &quot;configuration&quot; =&gt; WYE, &quot;name&quot; =&gt; &quot;l3&quot;, &quot;status&quot; =&gt; 1, &quot;qd&quot; =&gt; [0.006], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;vnom_kv&quot; =&gt; 1.0, &quot;source_id&quot; =&gt; &quot;load.l3&quot;, &quot;load_bus&quot; =&gt; 3…), 3 =&gt; Dict{String, Any}(&quot;model&quot; =&gt; POWER, &quot;connections&quot; =&gt; [1], &quot;configuration&quot; =&gt; WYE, &quot;name&quot; =&gt; &quot;l1&quot;, &quot;status&quot; =&gt; 1, &quot;qd&quot; =&gt; [0.006], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;vnom_kv&quot; =&gt; 1.0, &quot;source_id&quot; =&gt; &quot;load.l1&quot;, &quot;load_bus&quot; =&gt; 3…), 1 =&gt; Dict{String, Any}(&quot;model&quot; =&gt; POWER, &quot;connections&quot; =&gt; [2], &quot;configuration&quot; =&gt; WYE, &quot;name&quot; =&gt; &quot;l2&quot;, &quot;status&quot; =&gt; 1, &quot;qd&quot; =&gt; [0.006], &quot;vbase&quot; =&gt; 0.23094010767585033, &quot;vnom_kv&quot; =&gt; 1.0, &quot;source_id&quot; =&gt; &quot;load.l2&quot;, &quot;load_bus&quot; =&gt; 3…)), :arcs_branch_to =&gt; [(2, 1, 2), (3, 2, 4), (1, 3, 1)], :is_projected =&gt; true, :bus_arcs_transformer =&gt; Dict(4 =&gt; [], 2 =&gt; [], 3 =&gt; [], 1 =&gt; [])…)), :per_unit =&gt; true))), Dict{Symbol, Any}(:dep =&gt; Dict{Symbol, Any}(), :it =&gt; Dict{Symbol, Any}(:pmd =&gt; Dict{Symbol, Any}(:nw =&gt; Dict{Int64, Any}(0 =&gt; Dict{Symbol, Any}(:p =&gt; Dict{Any, Any}((1, 3, 1) =&gt; 1-dimensional DenseAxisArray{JuMP.AffExpr,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.AffExpr}:
 -0_(1,1,3)_p[1]
 -0_(1,1,3)_p[2]
 -0_(1,1,3)_p[3], (2, 2, 1) =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.VariableRef}:
 0_(2,2,1)_p[1]
 0_(2,2,1)_p[2]
 0_(2,2,1)_p[3], (1, 1, 3) =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.VariableRef}:
 0_(1,1,3)_p[1]
 0_(1,1,3)_p[2]
 0_(1,1,3)_p[3], (3, 2, 4) =&gt; 1-dimensional DenseAxisArray{JuMP.AffExpr,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.AffExpr}:
 -0_(3,4,2)_p[1]
 -0_(3,4,2)_p[2]
 -0_(3,4,2)_p[3], (3, 4, 2) =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.VariableRef}:
 0_(3,4,2)_p[1]
 0_(3,4,2)_p[2]
 0_(3,4,2)_p[3], (2, 1, 2) =&gt; 1-dimensional DenseAxisArray{JuMP.AffExpr,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.AffExpr}:
 -0_(2,2,1)_p[1]
 -0_(2,2,1)_p[2]
 -0_(2,2,1)_p[3]), :se =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, Int64[]
And data, a 0-element Vector{JuMP.VariableRef}, :qsw =&gt; Dict{Any, Any}(), :ps =&gt; Dict{Any, Any}(), :sc =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, Int64[]
And data, a 0-element Vector{JuMP.VariableRef}, :qsc =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, Int64[]
And data, a 0-element Vector{JuMP.VariableRef}, :pt =&gt; Dict{Any, Any}(), :qd =&gt; Dict{Int64, Any}(), :pg_bus =&gt; Dict{Int64, Any}(1 =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.VariableRef}:
 0_pg_1[1]
 0_pg_1[2]
 0_pg_1[3]), :sd =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, Int64[]
And data, a 0-element Vector{JuMP.VariableRef}…))))), Dict{Symbol, Any}(:dep =&gt; Dict{Symbol, Any}(), :it =&gt; Dict{Symbol, Any}(:pmd =&gt; Dict{Symbol, Any}(:nw =&gt; Dict{Int64, Any}(0 =&gt; Dict{Symbol, Any}(:lam_kcl_r =&gt; Dict{Int64, Array{JuMP.ConstraintRef, N} where N}(4 =&gt; [0_(3,4,2)_p[1] - 0_pg_1[1] = 0.0, 0_(3,4,2)_p[2] - 0_pg_1[2] = 0.0, 0_(3,4,2)_p[3] - 0_pg_1[3] = 0.0], 2 =&gt; [0_(2,2,1)_p[1] - 0_(3,4,2)_p[1] = 0.0, 0_(2,2,1)_p[2] - 0_(3,4,2)_p[2] = 0.0, 0_(2,2,1)_p[3] - 0_(3,4,2)_p[3] = 0.0], 3 =&gt; [-0_(1,1,3)_p[1] = -0.018000000000000002, -0_(1,1,3)_p[2] = -0.012, -0_(1,1,3)_p[3] = -0.012], 1 =&gt; [-0_(2,2,1)_p[1] + 0_(1,1,3)_p[1] = 0.0, -0_(2,2,1)_p[2] + 0_(1,1,3)_p[2] = 0.0, -0_(2,2,1)_p[3] + 0_(1,1,3)_p[3] = 0.0]), :lam_kcl_i =&gt; Dict{Int64, Array{JuMP.ConstraintRef, N} where N}(4 =&gt; [], 2 =&gt; [], 3 =&gt; [], 1 =&gt; [])))))), Dict{Symbol, Any}(:dep =&gt; Dict{Symbol, Any}(), :it =&gt; Dict{Symbol, Any}(:pmd =&gt; Dict{Symbol, Any}(:nw =&gt; Dict{Int64, Any}(0 =&gt; Dict{Symbol, Any}(:gen =&gt; Dict{Any, Any}(1 =&gt; Dict{Any, Any}(:pg =&gt; 1-dimensional DenseAxisArray{JuMP.VariableRef,1,...} with index sets:
    Dimension 1, [1, 2, 3]
And data, a 3-element Vector{JuMP.VariableRef}:
 0_pg_1[1]
 0_pg_1[2]
 0_pg_1[3])), :load =&gt; Dict{Any, Any}(2 =&gt; Dict{Any, Any}(:pd =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [3]
And data, a 1-element Vector{Float64}:
 0.012, :pd_bus =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [3]
And data, a 1-element Vector{Float64}:
 0.012), 3 =&gt; Dict{Any, Any}(:pd =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [1]
And data, a 1-element Vector{Float64}:
 0.018000000000000002, :pd_bus =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [1]
And data, a 1-element Vector{Float64}:
 0.018000000000000002), 1 =&gt; Dict{Any, Any}(:pd =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [2]
And data, a 1-element Vector{Float64}:
 0.012, :pd_bus =&gt; 1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [2]
And data, a 1-element Vector{Float64}:
 0.012))))))), Dict{Symbol, Any}(:dep =&gt; Dict{Symbol, Any}(), :it =&gt; Dict{Symbol, Any}(:pmd =&gt; Dict{Symbol, Any}(:nw =&gt; Dict{Int64, Any}(0 =&gt; Dict{Symbol, Any}())))), Dict{Symbol, Any}())</pre><p>╔═╡ 12ba02ff-91dd-4355-ad2b-f3ca3b61e318</p><pre><code class="language-julia">&quot;```$(pm_eng.model)```&quot; |&gt; Markdown.parse</code></pre><div class="markdown"><pre><code class="language-Min 0.5 0_pg_1&#91;1&#93; &#43; 0.5 0_pg_1&#91;2&#93; &#43; 0.5 0_pg_1&#91;3&#93;">Subject to
 0_&#40;3,4,2&#41;_p&#91;1&#93; - 0_pg_1&#91;1&#93; &#61; 0.0
 0_&#40;3,4,2&#41;_p&#91;2&#93; - 0_pg_1&#91;2&#93; &#61; 0.0
 0_&#40;3,4,2&#41;_p&#91;3&#93; - 0_pg_1&#91;3&#93; &#61; 0.0
 0_&#40;2,2,1&#41;_p&#91;1&#93; - 0_&#40;3,4,2&#41;_p&#91;1&#93; &#61; 0.0
 0_&#40;2,2,1&#41;_p&#91;2&#93; - 0_&#40;3,4,2&#41;_p&#91;2&#93; &#61; 0.0
 0_&#40;2,2,1&#41;_p&#91;3&#93; - 0_&#40;3,4,2&#41;_p&#91;3&#93; &#61; 0.0
 -0_&#40;1,1,3&#41;_p&#91;1&#93; &#61; -0.018000000000000002
 -0_&#40;1,1,3&#41;_p&#91;2&#93; &#61; -0.012
 -0_&#40;1,1,3&#41;_p&#91;3&#93; &#61; -0.012
 -0_&#40;2,2,1&#41;_p&#91;1&#93; &#43; 0_&#40;1,1,3&#41;_p&#91;1&#93; &#61; 0.0
 -0_&#40;2,2,1&#41;_p&#91;2&#93; &#43; 0_&#40;1,1,3&#41;_p&#91;2&#93; &#61; 0.0
 -0_&#40;2,2,1&#41;_p&#91;3&#93; &#43; 0_&#40;1,1,3&#41;_p&#91;3&#93; &#61; 0.0</code></pre>
</div><p>╔═╡ 07fc5a1b-4a9e-4a10-bf7a-d2682769ac97</p><pre><code class="language-julia">md&quot;&quot;&quot;
# Conclusion

This concludes the introduction to the `ENGINEERING` data model and conversion to the `MATHEMATICAL` model. We hope that you will find this new data model abstraction easy to use and simple to understand
&quot;&quot;&quot;</code></pre><div class="markdown"><h1>Conclusion</h1>
<p>This concludes the introduction to the <code>ENGINEERING</code> data model and conversion to the <code>MATHEMATICAL</code> model. We hope that you will find this new data model abstraction easy to use and simple to understand</p>
</div><p>╔═╡ Cell order: ╟─c55b2c42-9d27-11eb-24ca-e90a5472ffbb ╠═2661286b-2d18-42e3-b309-7974fc2db425 ╟─de92bc20-b125-4f3d-930a-b1da63d5cef5 ╠═f30cd0d0-b0da-4f63-a245-568a763a93d8 ╠═ac94e556-b544-4ca6-87bd-ff2d7a7414e7 ╟─1e791262-261d-4756-bec4-edebe4732700 ╠═89de80df-1dd0-4f94-a27d-74693a978059 ╟─e22a7d3e-3f21-41b0-abf2-2c723e87c57e ╠═5fe2d186-40c6-46c2-823e-9401cb3b6d6c ╟─c884fd5b-4ecb-402b-b228-01b9a61db8bf ╠═a5b736f9-2776-4760-b073-d02027baef13 ╟─29a8a560-7d5e-4929-877a-2dab17309968 ╠═9ac6b0ed-58a8-4079-aa9f-d70024f4d4b4 ╟─89846878-ebfc-49a5-91ef-762f692ba5ea ╠═8ba081b4-8444-48e0-afce-20649f7fdd01 ╟─2a8c1536-ef5f-4e37-b30e-1bb73982d7b0 ╠═83ce434c-0f92-46a8-8648-322084044600 ╠═2f9c3f64-3e5d-423f-939e-8d96bd19e7fe ╟─f06b9592-0e16-4fd1-bf6e-624ec0cdb8fb ╠═b15593b9-f775-47af-aa9b-4980a4028faa ╟─2e4fe000-449c-4fc0-8707-4c51ac50ab03 ╠═36ca17bc-b560-48c9-988f-255780479d05 ╟─7e5811cf-86a2-43fb-8c94-44091f33c031 ╠═026088f7-b1df-4647-ad81-52c6c8ea7944 ╟─5f72ecec-bb3f-4231-93c1-719e38e17be4 ╠═f070dbbc-1a55-48f2-aa21-2119eb573b5b ╟─f3458a5c-70c6-4d0c-8253-4feb0c87ee76 ╠═542e592f-8f75-41f9-8f98-5373b431fcc6 ╟─d0e02ee5-f57c-4286-940d-b01097c840be ╠═e852712c-d09a-41e1-9785-308c219c7ad8 ╟─0eba403e-c2ba-4af3-8dcc-fe14a3c22bd7 ╟─8d5701d1-9e91-43b5-975b-fc8e0e306e99 ╠═745f33bf-98d7-4b27-95fd-ec6bf5e3d5cf ╟─fb81d3c1-a47b-46d9-b463-1766022be114 ╠═27d5a237-4c2e-4b14-a082-f4847153c8d5 ╟─564200e0-2080-44da-8dbf-37c5e3a38412 ╠═8b066039-ed65-4617-b404-86952d3fc78e ╟─a09de8ab-c1e1-4c9f-9d86-4268ce503cae ╠═763a1504-f927-4dfc-a042-ac66324708a9 ╠═e7b588e9-fb5f-4383-b5c6-bce9ed8f5a60 ╟─f882f070-74af-4f3b-9ad1-bd7ad453778f ╠═f2fa779e-f62d-4053-b055-e9f0aee6c3f7 ╟─544108d1-d1a7-4dc6-9a3c-6a10025cb8a3 ╠═ae8daf6c-4055-497e-905c-d6d5a6373ad3 ╟─3d86989a-a4db-4766-aec7-abc9a25ffde8 ╠═7a86e26d-fdf6-41b6-b1dd-dc0c4a8e9d50 ╠═82e9330b-2e94-42a1-b56d-430674b11241 ╟─2c358d7a-5d84-4f62-a147-577bb775ac7f ╠═5e5dd24c-95b5-4951-8547-13e20bb0feec ╠═45c320dd-e0b2-46ec-af09-d83e5652026d ╟─723f4e26-8065-4e22-8c5c-de32d2e42b47 ╠═58f80651-4a44-4781-a6c0-a056ec76b07e ╟─b1e55263-9c76-43b2-b91c-115b2f080182 ╠═2cdd682a-b97f-49dc-8829-47e7146497b9 ╠═74836b2c-db67-4435-a552-ba5c3e93e43f ╟─2bf802e2-f769-48db-adef-a5a066c565c2 ╠═4020d67a-4a9e-4030-b7cd-e5d60e78495c ╟─dde2da59-63fa-4549-8829-491e5f3c675e ╟─2c375878-f16b-4833-9aaa-b826fbe056a2 ╠═a7348fc8-b25e-4ecf-9fe6-314036b7df9c ╟─54280696-beec-47ee-8114-ea9311aca9eb ╠═1dc06007-b413-4cbb-b43b-2c7955ecb6d2 ╟─96a65bdc-7ee4-4e9f-94f5-8a83f7512fe9 ╠═545c9270-257a-46e8-970d-6a9fcf09dc17 ╟─fda420a1-e563-4a41-84d4-2a570bf163ae ╠═785a1c39-aa56-4244-b7b9-31d7a31b73c3 ╠═ad48b3ad-ede1-4109-9647-007c1d8d196c ╟─666223d5-802a-4164-882c-8ab1a1319d6d ╠═e3fe0a5e-9431-453d-b7e5-821de624a4ef ╟─5ab6cd16-3c24-4f60-bdf2-7f48b3e25085 ╠═05360163-4a6f-41da-8fae-070e327c2605 ╟─b8e01ce2-d7f7-4c73-8230-9fdeecab2c4e ╠═96757dde-52be-4930-9bdd-9303bb715e55 ╠═867d8d1d-042a-42ec-843e-56b8ba2db96a ╟─db4d9eb9-e120-4489-a3c2-48c43f2a3c3b ╠═4603bc56-c402-48af-9715-0722e42d90f7 ╟─12ba02ff-91dd-4355-ad2b-f3ca3b61e318 ╟─07fc5a1b-4a9e-4a10-bf7a-d2682769ac97</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../beginners_guide/">« Beginners Guide</a><a class="docs-footer-nextpage" href="../engineering_model_helper_functions/">Engineering Model Helper Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 April 2021 21:04">Friday 16 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
